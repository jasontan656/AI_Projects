# Codex 工作流系统 V2 使用指南

版本: 2.1
更新日期: 2025-10-11

---

## 系统概述

本系统是一套基于 SpecKit 工程实践优化的 AI 辅助开发工作流，用于将开发需求转化为可执行的开发步骤，并通过 AI 自动完成实现。

### 核心特点

1. **5步工作流**：需求分析 → 开发计划 → 技术决策 → 任务清单 → 自动执行
2. **工程级提示词**：精确控制流程、多级质量门控、详细错误处理
3. **脚本集成**：PowerShell 脚本自动化上下文获取
4. **逐层细化**：从业务需求到技术细节，逐步补充信息
5. **人工审核**：每个阶段文档生成后，人工审核后再进入下一步

---

## 工作流程图

```
用户需求
    ↓
[步骤1] DevFuncDemandsWrite_V2
    ↓ 生成 DemandDescription.md (需求文档)
    ↓ 人工审核
    ↓
[步骤2] DevPlanGeneration_V2
    ↓ 生成 DevPlan.md (开发计划: 架构、模块、目录)
    ↓ 人工审核
    ↓
[步骤3] TechDecisionsGeneration_V2
    ↓ 生成 Tech_Decisions.md (技术决策: 依赖、提示词、API、配置)
    ↓ 人工审核
    ↓
[步骤4] DevPipelineGeneration_V2
    ↓ 生成 Tasks.md (任务清单: 原子操作步骤)
    ↓ 人工审核
    ↓
[步骤5] DevPiplineExcute_V2
    ↓ 执行开发、测试、验证
    ↓
完成交付
```

---

## 快速开始

### 前置准备

1. **环境要求**：
   - Windows 10/11 + PowerShell 5.1+
   - Codex CLI 工具（GPT-5）
   - Git（用于版本管理）

2. **项目结构**：
   ```
   D:\AI_Projects\
   ├── .codex\
   │   └── prompts\              # 工作流提示词目录
   │       ├── DevFuncDemandsWrite_V2.md
   │       ├── DevPlanGeneration_V2.md
   │       ├── TechDecisionsGeneration_V2.md
   │       ├── DevPipelineGeneration_V2.md
   │       └── DevPiplineExcute_V2.md
   ├── CodexFeatured\
   │   ├── Common\               # 项目规范
   │   │   ├── BackendConstitution.yaml
   │   │   ├── CodeCommentStandard.yaml
   │   │   └── BestPractise.yaml
   │   ├── DevPlans\             # 输出目录
   │   │   └── {COUNT_3D}_{INTENT_TITLE_2_4}\
   │   │       ├── DemandDescription.md
   │   │       ├── DevPlan.md
   │   │       ├── Tech_Decisions.md
   │   │       └── Tasks.md
   │   └── Scripts\              # 辅助脚本
   │       ├── get-demand-context.ps1
   │       ├── get-plan-context.ps1
   │       ├── get-tech-context.ps1
   │       ├── get-task-context.ps1
   │       └── verify-execution.ps1
   └── Kobe\                     # 项目代码库
   ```

---

## 详细使用指南

### 步骤1：生成需求文档（DevFuncDemandsWrite_V2）

**目标**：将用户输入的开发意图转化为结构化的需求文档

**使用方法**：

1. **运行上下文脚本**（可选，自动获取下一个编号）：
   ```powershell
   cd D:\AI_Projects
   .\CodexFeatured\Scripts\get-demand-context.ps1
   ```
   输出示例：
   ```
   下一个需求编号: 006
   目标目录: D:\AI_Projects\CodexFeatured\DevPlans\006_{待定}
   ```

2. **执行工作流**：
   ```bash
   codex -p .codex/prompts/DevFuncDemandsWrite_V2.md -a "我需要开发一个Telegram消息知识整理功能，将聊天记录中的有价值内容提取并归档"
   ```
   
   或者，如果已有需求文档草稿：
   ```bash
   codex -p .codex/prompts/DevFuncDemandsWrite_V2.md -a "请根据 CodexFeatured/DevFuncDemandsWrite/PromptDraft.md 生成需求文档"
   ```

3. **AI 执行流程**：
   - 加载所有项目规范文档（BackendConstitution.yaml等）
   - 扫描现有DevPlans目录，计算下一个编号
   - 分析需求，补充缺失信息
   - 生成需求文档（功能、数据、性能、交付物）
   - 执行质量门控验证
   - 输出：`CodexFeatured/DevPlans/006_TelegramKnowledgeCuration/DemandDescription.md`

4. **人工审核**：
   - 打开生成的 DemandDescription.md
   - 检查功能需求是否完整
   - 检查交付物清单是否明确
   - 检查性能指标是否合理
   - **修改后保存**，再进入下一步

**输出文件**：`DemandDescription.md`
- 包含：业务背景、功能需求、数据需求、性能指标、交付物清单、验收标准

---

### 步骤2：生成开发计划（DevPlanGeneration_V2）

**目标**：将需求文档转化为架构设计和开发计划

**使用方法**：

1. **运行上下文脚本**（可选）：
   ```powershell
   .\CodexFeatured\Scripts\get-plan-context.ps1
   ```
   输出示例：
   ```
   找到最新需求文档:
     目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
     需求文档: 存在
     开发计划: 待生成
   ```

2. **执行工作流**：
   ```bash
   codex -p .codex/prompts/DevPlanGeneration_V2.md
   ```
   
   注意：无需传入参数，工作流会自动定位最新需求文档

3. **AI 执行流程**：
   - 加载需求文档（DemandDescription.md）
   - 加载项目规范（BackendConstitution.yaml等）
   - 分析功能需求，设计架构方案
   - 规划目录结构、模块划分、接口设计
   - 生成开发计划文档
   - 执行质量门控验证
   - 输出：`CodexFeatured/DevPlans/006_TelegramKnowledgeCuration/DevPlan.md`

4. **人工审核**：
   - 打开生成的 DevPlan.md
   - 检查架构设计是否合理
   - 检查目录结构是否符合项目规范
   - 检查模块划分是否清晰
   - 检查接口设计是否完整
   - **修改后保存**，再进入下一步

**输出文件**：`DevPlan.md`
- 包含：架构方案、模块设计、目录结构、接口定义、数据模型概要

---

### 步骤3：生成技术决策（TechDecisionsGeneration_V2）

**目标**：将开发计划转化为详细的技术实现决策

**使用方法**：

1. **运行上下文脚本**（可选）：
   ```powershell
   .\CodexFeatured\Scripts\get-tech-context.ps1
   ```
   输出示例：
   ```
   找到最新开发计划:
     目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
     需求文档: 存在
     开发计划: 存在
     技术决策: 待生成
   ```

2. **执行工作流**：
   ```bash
   codex -p .codex/prompts/TechDecisionsGeneration_V2.md
   ```

3. **AI 执行流程**：
   - 加载需求文档和开发计划
   - 加载项目规范和现有代码库结构
   - 确定技术选型（依赖库、版本）
   - 定义大模型提示词（如果需要）
   - 定义API路由和测试命令（如果需要）
   - 定义数据模型字段（完整Pydantic定义）
   - 生成配置文件模板（.env、config.py）
   - 执行质量门控验证
   - 输出：`CodexFeatured/DevPlans/006_TelegramKnowledgeCuration/Tech_Decisions.md`

4. **人工审核**：
   - 打开生成的 Tech_Decisions.md
   - 检查依赖选型是否合理
   - 检查提示词模板是否完整（如果有）
   - 检查API路由是否符合现有规范（如果有）
   - 检查数据模型字段是否完整
   - 检查配置文件是否包含所有必需项
   - **修改后保存**，再进入下一步

**输出文件**：`Tech_Decisions.md`
- 包含：依赖清单、大模型提示词、API对接方案、数据字段规范、配置文件模板、实现路径映射

---

### 步骤4：生成任务清单（DevPipelineGeneration_V2）

**目标**：将需求、计划、技术决策综合生成可执行的任务步骤

**使用方法**：

1. **运行上下文脚本**（可选）：
   ```powershell
   .\CodexFeatured\Scripts\get-task-context.ps1
   ```
   输出示例：
   ```
   找到最新开发计划目录:
     目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
     需求文档: 存在
     开发计划: 存在
     技术决策: 存在
     任务清单: 待生成
   ```

2. **执行工作流**：
   ```bash
   codex -p .codex/prompts/DevPipelineGeneration_V2.md
   ```

3. **AI 执行流程**：
   - 加载所有前置文档（需求、计划、技术决策）
   - 构建需求到实现的映射
   - 按7个阶段拆解任务：
     * 阶段0：环境准备与依赖安装
     * 阶段1：基础结构与配置
     * 阶段2：数据模型定义
     * 阶段3：核心功能实现
     * 阶段4：API路由实现
     * 阶段5：Celery任务封装
     * 阶段6：集成与完善
     * 阶段7：测试验证
   - 确保每个 sub_step 是原子操作
   - 确保包含所有技术细节（从技术决策复制）
   - 执行质量门控验证
   - 输出：`CodexFeatured/DevPlans/006_TelegramKnowledgeCuration/Tasks.md`

4. **人工审核**：
   - 打开生成的 Tasks.md
   - 检查任务步骤是否覆盖所有功能需求
   - 检查技术细节是否完整（依赖、提示词、配置）
   - 检查任务原子性（每个 sub_step 可手动执行）
   - 检查验收标准是否明确
   - **修改后保存**，再进入下一步

**输出文件**：`Tasks.md`
- 包含：技术决策摘要、7阶段任务清单、执行顺序说明、性能验证清单、功能验收清单

---

### 步骤5：执行任务清单（DevPiplineExcute_V2）

**目标**：自动执行任务清单，完成代码实现、测试、验证

**使用方法**：

1. **运行上下文脚本**（可选）：
   ```powershell
   .\CodexFeatured\Scripts\verify-execution.ps1
   ```
   输出示例：
   ```
   找到最新任务清单:
     目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
     任务清单: 存在
     执行报告: 待生成
   ```

2. **执行工作流**：
   ```bash
   codex -p .codex/prompts/DevPiplineExcute_V2.md
   ```

3. **AI 执行流程**：
   - 加载任务清单（Tasks.md）
   - 加载所有项目规范文档
   - 按阶段执行任务：
     * 创建目录、文件
     * 安装依赖
     * 编写代码（使用技术决策的提示词、配置）
     * 实现API路由
     * 编写测试
     * 运行功能验证
   - 执行多级质量门控（合规性、测试覆盖率、性能）
   - 输出执行报告

4. **人工验证**：
   - 运行测试：`pytest Kobe/tests/{功能模块名}/ -v`
   - 启动服务（如果有API）：`uvicorn Kobe.main:app --reload`
   - 手动测试核心功能
   - 检查日志输出是否正常
   - 检查性能指标是否达标

**输出**：完整的功能实现 + 测试 + 执行报告

---

## 配套脚本说明

所有脚本位于 `CodexFeatured/Scripts/` 目录下

### get-demand-context.ps1

**功能**：自动计算下一个需求编号

**使用方法**：
```powershell
.\CodexFeatured\Scripts\get-demand-context.ps1
```

**输出示例**：
```
下一个需求编号: 006
目标目录: D:\AI_Projects\CodexFeatured\DevPlans\006_{待定}
现有需求数量: 5
```

**JSON 输出**（供工作流脚本调用）：
```powershell
.\CodexFeatured\Scripts\get-demand-context.ps1 -Json
```

---

### get-plan-context.ps1

**功能**：自动定位最新需求文档

**使用方法**：
```powershell
.\CodexFeatured\Scripts\get-plan-context.ps1
```

**输出示例**：
```
找到最新需求文档:
  目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
  编号: 006
  标识: TelegramKnowledgeCuration
  需求文档: 存在
  开发计划: 待生成
```

---

### get-tech-context.ps1

**功能**：自动定位最新开发计划

**使用方法**：
```powershell
.\CodexFeatured\Scripts\get-tech-context.ps1
```

**输出示例**：
```
找到最新开发计划:
  目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
  需求文档: 存在
  开发计划: 存在
  技术决策: 待生成
```

---

### get-task-context.ps1

**功能**：自动定位包含所有前置文档的目录

**使用方法**：
```powershell
.\CodexFeatured\Scripts\get-task-context.ps1
```

**输出示例**：
```
找到最新开发计划目录:
  目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
  编号: 006
  标识: TelegramKnowledgeCuration
  需求文档: 存在
  开发计划: 存在
  技术决策: 存在
  任务清单: 待生成
```

---

### verify-execution.ps1

**功能**：自动定位最新任务清单

**使用方法**：
```powershell
.\CodexFeatured\Scripts\verify-execution.ps1
```

**输出示例**：
```
找到最新任务清单:
  目录: D:\AI_Projects\CodexFeatured\DevPlans\006_TelegramKnowledgeCuration
  任务清单: 存在
  执行报告: 待生成
```

---

## 质量门控说明

每个工作流都包含多级质量门控，确保输出质量

### DevFuncDemandsWrite_V2 质量门控

- **文档完整性检查**：所有必需章节存在
- **业务闭环检查**：输入→处理→输出完整
- **交付物可验证性检查**：交付物可测试
- **性能指标合理性检查**：指标有基准值

### DevPlanGeneration_V2 质量门控

- **需求覆盖度检查**：所有功能点有对应模块
- **架构合理性检查**：模块职责单一、依赖合理
- **目录结构规范检查**：符合项目规范
- **接口完整性检查**：输入输出定义明确

### TechDecisionsGeneration_V2 质量门控

- **技术选型合规性检查**：符合BackendConstitution约束
- **依赖完整性检查**：所有依赖有版本号和用途说明
- **提示词完整性检查**：模板、参数、错误处理完整
- **配置文件完整性检查**：所有必需配置项存在

### DevPipelineGeneration_V2 质量门控

- **前置文档引用完整性检查**：引用所有技术决策
- **业务目标覆盖度检查**：所有功能点有任务步骤
- **任务原子性检查**：sub_step可手动执行
- **技术细节完整性检查**：依赖、配置、提示词完整
- **验收标准完整性检查**：每个Step有acceptance

### DevPiplineExcute_V2 质量门控

- **宪法合规性门控**：代码符合技术栈约束
- **测试覆盖率门控**：覆盖率≥70%
- **性能指标门控**：满足需求文档的性能指标

---

## 常见问题

### Q1: 如何修改已生成的文档？

**A**: 可以直接打开文档编辑，AI不会覆盖已修改的内容（除非显式覆盖）

### Q2: 工作流执行失败怎么办？

**A**: 
1. 检查错误信息，确认是哪个质量门控失败
2. 检查前置文档是否存在且完整
3. 检查项目规范文档是否正确加载
4. 如果是脚本错误，手动传入参数绕过脚本

### Q3: 如何跳过某个阶段？

**A**: 不建议跳过，但如果必须：
- 手动创建对应文档（按格式要求）
- 确保文档路径符合规范
- 继续下一步工作流

### Q4: 如何为现有功能生成文档？

**A**: 在步骤1执行时，传入参数：
```bash
codex -p .codex/prompts/DevFuncDemandsWrite_V2.md -a "请分析 Kobe/VisaDBOperation/ 模块，生成需求文档"
```

### Q5: 如何使用GPT-5（Codex CLI）？

**A**: 
- 本系统专门优化了GPT-5的提示词（详细、无歧义、指令明确）
- 使用 `codex -p <prompt_file>` 命令执行工作流
- GPT-5不会过度联想，需要明确告知所有细节

### Q6: 为什么需要5步而不是3步？

**A**: 
- 原3步（需求→任务→执行）跳跃太大，导致任务清单太概括
- 新增"开发计划"和"技术决策"两步，逐层细化：
  * 需求文档：业务需求（做什么）
  * 开发计划：架构设计（怎么组织）
  * 技术决策：技术细节（用什么实现）
  * 任务清单：执行步骤（怎么做）
- 每步都需要人工审核，确保不跑偏

### Q7: 如何确保任务清单足够详细？

**A**: 
- 技术决策文档必须包含完整的技术细节（依赖、提示词、配置）
- 任务清单会从技术决策文档复制完整内容
- 每个 sub_step 必须是原子操作（可手动执行）
- 质量门控会验证技术细节完整性

---

## 最佳实践

### 1. 逐步完善，人工审核

- 每完成一步，仔细审核输出文档
- 修正偏差后再进入下一步
- 不要一次运行整个流程

### 2. 利用脚本自动化

- 使用 `get-*-context.ps1` 脚本自动获取上下文
- 减少手动传参错误

### 3. 遵守项目规范

- 定期更新 `BackendConstitution.yaml` 等规范文档
- 确保AI加载最新规范

### 4. 保留历史版本

- 使用 Git 管理生成的文档
- 每个阶段提交一次

### 5. 测试先行

- 在步骤1就明确验收标准
- 在步骤4确保测试用例完整
- 在步骤5执行前人工预验证

---

## 附录：工作流版本对比

| 版本 | 步骤数 | 核心改进 |
|------|--------|----------|
| V1 | 3步 | 基础工作流，任务清单过于概括 |
| V2.0 | 3步 | 引入工程级提示词、质量门控 |
| V2.1 | 5步 | 新增开发计划、技术决策两步，任务清单详细度大幅提升 |

### V1 → V2.1 主要变化

- **步骤拆分**：3步→5步，逐层细化
- **文档结构**：从单一文档到多层文档
- **技术细节**：从"让AI自己判断"到"明确定义所有细节"
- **提示词质量**：从"简洁指令"到"工程级控制流"
- **质量保障**：从"无验证"到"多级门控"

---

## 支持与反馈

如有问题或建议，请：
1. 检查本使用指南
2. 查看 `CodexFeatured/Analysis_Report.md`（SpecKit分析）
3. 查看各工作流的错误处理章节
4. 修改提示词文件以适应特定需求

---

**版本**: 2.1
**最后更新**: 2025-10-11
**基于**: SpecKit 工程实践 v2.1.1
