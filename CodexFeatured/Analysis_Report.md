# 提示词系统对比分析报告

生成时间：2025-10-11
分析对象：SpecKit vs 用户自定义提示词系统

---

## 1. 核心差异总结

### 1.1 SpecKit 的工程级特征

#### **精准的执行流程控制**
```markdown
## 执行流程（/plan 命令范围）
```
1. 从输入路径加载功能规范
   → 如果未找到：ERROR "在 {path} 没有找到功能规范"
2. 填写技术上下文（扫描 NEEDS CLARIFICATION）
   → 从上下文检测项目类型（web=前端+后端，mobile=应用+API）
   → 基于项目类型设置结构决策
3. 基于宪法文档内容填写宪法检查部分。
4. 评估下面的宪法检查部分
   → 如果存在违规：在复杂性跟踪中记录
   → 如果无法证明：ERROR "首先简化方法"
   → 更新进度跟踪：初始宪法检查
```
```

**关键特点：**
- 明确的步骤编号
- 清晰的条件分支（→ 符号）
- 错误处理指令（ERROR）
- 状态跟踪更新

#### **运行时脚本集成**
```yaml
scripts:
  sh: scripts/bash/setup-plan.sh --json
  ps: scripts/powershell/setup-plan.ps1 -Json
```

**作用：**
- 自动获取上下文信息（路径、分支、规范）
- 减少人工输入错误
- 标准化数据格式（JSON）

#### **命令参数处理**
```markdown
用户输入可以由代理直接提供，或作为命令参数传入——在继续执行提示词之前（若不为空），你**必须**予以考虑。

用户输入：

$ARGUMENTS

根据作为参数提供的实现详情，执行以下操作：
```

**设计理念：**
- 显式声明参数获取点
- 强制验证用户输入
- 参数优先级明确

#### **门控检查机制**
```markdown
## 宪法检查
*门控：必须在阶段0研究前通过。在阶段1设计后重新检查。*
```

**保证：**
- 质量关卡
- 多阶段验证
- 防止劣质设计进入实现阶段

#### **进度跟踪清单**
```markdown
## 进度跟踪
*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 阶段0：研究完成（/plan 命令）
- [ ] 阶段1：设计完成（/plan 命令）
- [ ] 阶段2：任务规划完成（/plan 命令 - 仅描述方法）
- [ ] 阶段3：任务生成（/tasks 命令）
- [ ] 阶段4：实现完成
- [ ] 阶段5：验证通过
```

**价值：**
- AI 在执行过程中自我追踪
- 用户可视化进度
- 支持断点恢复

---

### 1.2 用户现有系统的特征

#### **优点：**
1. **YAML 格式清晰** - 结构化参数定义
2. **工作流导向** - 明确的 objectives 和 steps
3. **领域适配良好** - 深度理解自己的业务需求
4. **规范引用全面** - 加载了大量项目规范文件

#### **不足：**
1. **执行流程模糊** - 缺少明确的条件分支和错误处理
2. **缺少运行时支持** - 没有脚本自动获取上下文
3. **参数验证弱** - 未强制验证输入完整性
4. **进度追踪缺失** - AI 执行时无自我检查点
5. **门控机制不足** - 没有阶段性质量把关

---

## 2. 关键差异对比表

| 维度 | SpecKit | 用户系统 | 改进方向 |
|-----|---------|---------|---------|
| **执行流程** | 明确步骤 + 条件分支 + ERROR 处理 | 描述性 actions 列表 | 添加条件分支和错误指令 |
| **参数处理** | $ARGUMENTS + 强制验证 | YAML params 定义 | 显式声明参数获取点 |
| **脚本支持** | sh/ps 脚本自动化 | 手动运行 Python 脚本 | 创建 PowerShell 脚本 |
| **门控检查** | 多阶段宪法检查 | 仅在最后 self_check | 在关键节点添加门控 |
| **进度追踪** | 嵌入式检查清单 | 无 | 添加阶段状态追踪 |
| **错误处理** | 明确 ERROR 指令 | 描述性"验证" | 添加失败分支处理 |
| **输出验证** | acceptance 清单 | acceptance 清单 | 保持，但增强验证逻辑 |

---

## 3. SpecKit 提示词的"工程语言"特征

### 3.1 精准的控制流语法

#### **条件分支**
```
→ 如果 [条件]：[动作]
→ 如果 [条件]：ERROR "[错误消息]"
```

#### **循环/遍历**
```
对于 [集合] 中的每个 [元素]：
  [动作]
```

#### **门控**
```
*门控：必须在 [阶段] 前通过*
*前提条件：[文件] 完成*
```

#### **状态机**
```
1. [动作] → [输出] → [状态更新]
2. 如果 [条件]：返回 [步骤]
3. 停止 - 准备 [下一命令]
```

### 3.2 runtime 概念的使用

**SpecKit 中的 runtime：**
- 脚本执行时动态获取的值
- 避免硬编码路径
- 支持多项目复用

**实现方式：**
```markdown
1. 从仓库根目录运行 `{SCRIPT}` 并解析JSON以获取 FEATURE_SPEC、IMPL_PLAN、SPECS_DIR、BRANCH。
2. 所有后续文件路径必须是绝对路径。
```

**对比用户系统：**
```yaml
params:
  OUTPUT_DIR_PATH: "D:/AI_Projects/CodexFeatured/DevPlans"  # 硬编码
  COUNT_3D: "{{RUNTIME_GENERATE}}"                          # 仅标注，无机制
```

### 3.3 令牌效率优化

**SpecKit 的做法：**
```markdown
5. **增量更新代理文件**（O(1)操作）：
   - 运行 `{SCRIPT}`
   - 如果存在：仅从当前计划添加新技术
   - 在标记之间保留手动添加
   - 更新最近变更（保留最近3个）
   - 为了令牌效率保持在150行以下
```

**启示：**
- 明确算法复杂度（O(1)）
- 增量更新而非全量重写
- 令牌预算意识

---

## 4. 改进策略

### 4.1 保留用户系统的优点
1. YAML 格式的参数定义（更清晰）
2. 工作流命名和 objectives（业务导向）
3. 规范文件的引用体系（领域知识）
4. 详细的 acceptance 标准（质量保证）

### 4.2 引入 SpecKit 的工程实践
1. **执行流程改造**
   ```markdown
   ## 执行流程（{工作流名称}）
   ```
   1. 动作1
      → 条件1：分支1
      → 条件2：ERROR "错误消息"
      → 更新进度：检查点1
   2. 动作2
   ```
   ```

2. **脚本集成**
   ```yaml
   scripts:
     ps: CodexFeatured/Scripts/{workflow_name}.ps1 -Json
   ```

3. **参数获取标准化**
   ```markdown
   用户输入（若提供）：

   $ARGUMENTS

   1. 解析用户输入并验证必需参数
      → 如果缺少：ERROR "必需参数 [参数名] 未提供"
   ```

4. **进度追踪**
   ```markdown
   ## 进度跟踪
   **阶段状态**：
   - [ ] 步骤1：加载完成
   - [ ] 步骤2：分析完成
   - [ ] 步骤3：生成完成
   - [ ] 步骤4：验证通过
   ```

5. **门控机制**
   ```markdown
   ## 质量门控
   *门控：必须在生成输出前通过*

   - [ ] 规范对齐检查
   - [ ] 覆盖度验证
   - [ ] 命名规则验证
   ```

---

## 5. 具体改进示例

### 原始（用户系统）
```yaml
steps:
  - id: load_prompt
    name: 加载用户提示词与生成命名
    actions:
      - 读取并理解 io.user_prompt_path
      - 提取用户意图的核心诉求与显式参数
      - 识别用户提供的上下文信息（URL/文件路径/数据源/目标系统等）
```

### 改进后（融合 SpecKit 风格）
```markdown
## 执行流程（DevFuncDemandsWrite 工作流）

**输入验证**：
用户输入（命令参数或直接提供）：

$ARGUMENTS

1. **加载并验证用户提示词**：
   - 读取 `CodexFeatured/DevFuncDemandsWrite/PromptDraft.md`
     → 如果文件不存在：ERROR "提示词文件未找到，路径: {path}"
     → 如果文件为空：ERROR "提示词内容为空，请先撰写需求描述"
   - 解析用户核心诉求：
     → 提取主要功能域关键词
     → 识别显式参数（URL、文件路径、数据源）
     → 提取技术约束与特殊要求
   - 更新进度：用户意图解析完成

2. **生成工作目录命名**：
   - 扫描 `D:/AI_Projects/CodexFeatured/DevPlans` 获取现有编号
     → 提取所有匹配 `^\d{3}_.*` 的目录名
     → 计算 COUNT_3D = max(现有编号) + 1，左填充为3位
     → 如果无现有目录：COUNT_3D = "001"
   - 基于用户意图生成 INTENT_TITLE_2_4：
     → 提取 2-4 个核心英文词（名词/动词）
     → 移除停用词（the, a, an, of, for, with, and, to, in）
     → 转为 PascalCase 格式
     → 验证正则：`^[A-Z][a-z]+(?:[A-Z][a-z]+){1,3}$`
     → 如果验证失败：使用 "GeneralTask" 作为兜底
   - 构造输出路径：`${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}`
   - 更新进度：命名生成完成

3. **加载项目上下文**：
   ...
```

---

## 6. 实施路线图

### 阶段1：提示词重构（当前）
- 重写 DevFuncDemandsWrite.md
- 重写 DevPipelineGeneration.md  
- 重写 DevPiplineExcute.md

### 阶段2：脚本支持（配套）
- 创建 get-demand-context.ps1
- 创建 get-task-context.ps1
- 创建 verify-execution.ps1

### 阶段3：模板标准化
- 需求文档模板
- 任务清单模板
- 执行报告模板

### 阶段4：测试验证
- 用真实需求测试完整流程
- 对比新旧版本质量差异
- 迭代优化

---

## 7. 预期收益

1. **AI 理解准确度提升** - 明确的控制流减少歧义
2. **错误处理能力增强** - 主动捕获异常情况
3. **可维护性提升** - 标准化的工程语言
4. **复用性提升** - 脚本支持多项目适配
5. **质量保证增强** - 门控机制防止劣质输出

---

## 8. 关键takeaway

**SpecKit 的核心不是提示词本身，而是：**
1. 把 AI 当作程序来"编程"（控制流、错误处理、状态机）
2. 用脚本处理 runtime 信息，减少硬编码
3. 多阶段门控保证质量
4. 进度追踪让 AI 自我管理
5. 令牌效率优化（算法复杂度意识）

**用户系统的独特价值：**
1. YAML 格式更适合参数管理
2. 业务领域深度理解
3. 规范文件体系完善

**最佳方案：融合两者优点**
- 保留用户的 YAML 参数定义和业务逻辑
- 引入 SpecKit 的执行流程控制和工程实践
- 创建配套的 PowerShell 脚本
- 标准化模板和验收标准


