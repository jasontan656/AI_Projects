---

env_policy:
  no_hardcode: true

prompts:
  enforcement: conditional
  include_mode: inline_snapshot
  embed_as: python_literal
  location:
    section: Prompts
    anchor: prompts_snapshot
  variables:
    required: []
    must_resolve: true
    sources_allowed: [env, repo, header]
  redaction:
    no_secrets_in_doc: true
    deny_patterns: [sk-*, api_key=*, token=*]

  triggers:
    section_exists: Prompts
    anchor_exists: prompts_snapshot
    fences_any_of: [yaml, json, text]
    tags_any: [ai, agent, prompt, llm]
    has_agents_spec: true
doc_contract:
  mode: python_narrative_code
  python_version: "3.11+"
  allow_inline_calls: true
  allow_chained_calls: true
  line_kinds: [def, class, import, from, for, while, if, elif, else, try, except, with, return, assign, call, read, write, error, note, source]
  layout:
    narrative_may_be_plaintext: true
    code_line_prefixes: [from, import, class, def, if, elif, else, try, except, for, while, with, return]
  narration_rules:
    import_explained: required
    def_explained: required
    call_expansion: required_1_to_2_lines
    types_cn_alias_required:
      str: 字符串
      int: 整数
      list: 列表
      dict: 字典
      Path: 路径
    function_coverage: all
  ordering:
    prefer_chinese_then_code: true
  templates:
  examples_snippet: |
    """文件: {files.path}
    模块: {files.primary_module}
    同步策略: {files.sync_policy}  ← 文档为真相源；代码生成/同步以此路径为准
    目的: 先中文解释，再给真实 import/def/调用/赋值/类型注解；关键调用后 1–2 行动作语义扩展；生成内容可直译为可运行代码。
    """

    """从 python 内置功能 __future__ 导入 annotations：
    用途：推迟类型注解解析，使当前作用域可引用稍后定义的类型名；有利于类型检查与跨模块依赖，不改变运行时行为。"""
    from __future__ import annotations

    """从标准库 pathlib 导入 Path（路径）：
    动机：用“路径”替代“字符串”表达文件系统路径，获得跨平台拼接/存在性/规范化等能力；比直接拼接斜杠更稳健。"""
    from pathlib import Path

    """从 typing 导入 Protocol（协议）、TypedDict（字典类型）、Iterable（可迭代）、Sequence（序列）：
    意图：用“协议”描述依赖外形（便于注入与替换），用“字典类型”声明返回结构，用“可迭代/序列”约束集合语义。"""
    from typing import Protocol, TypedDict, Iterable, Sequence

    """依赖接口外形（protocol）——运行期注入真实实现；此处仅给“能力签名”：
    Filesystem（文件系统读写/遍历/存在性），Tokenizer（文本分词），Ranker（相关性重排），IndexStore（倒排索引存储）。"""
    class Filesystem(Protocol):
        def listdir(self, root: Path) -> Iterable[Path]: ...
        def read_text(self, path: Path, encoding: str = "utf-8") -> str: ...
        def exists(self, path: Path) -> bool: ...

    class Tokenizer(Protocol):
        def split(self, text: str, max_tokens: int = 2048) -> list[str]: ...

    class Ranker(Protocol):
        def score(self, docs: Sequence[str], top_k: int = 50) -> list[int]: ...

    class IndexStore(Protocol):
        def append(self, tokens: list[str]) -> None: ...
        def lookup(self, query: str) -> list[str]: ...
        def size(self) -> int: ...
        def count(self) -> int: ...

    """返回结构（字典类型）：
    index_id（字符串）＝由路径推导；size（整数）＝当前倒排条目数。"""
    class IndexStats(TypedDict):
        index_id: str
        size: int

    """函数：build_index —— 构建/追加构建倒排索引（def_explained=required）
    整体行为（中文→代码顺序）：
    1) 校验路径存在且可读；不存在/不可读 → 抛 NOT_FOUND / ACCESS_DENIED
       read: fs.exists(collection_path)；error: NOT_FOUND | ACCESS_DENIED；source: repo
    2) 遍历目录 → 逐文档读取 → 分词 → 写入索引
       read: fs.listdir / fs.read_text；call: tokenizer.split(text, max_tokens=2048)
       write: index.append(tokens)（追加 posting，不覆盖既有条目）
       call_expansion: 分词＝按空白/标点切分；过滤停用词；Unicode 规范化；产出词面/位置/频次特征；不修改原文
    3) 返回 {"index_id": 路径推导, "size": index.size()}；指标：index_build_time_ms.p95 < 300_000；source: tests
    类型别名使用（types_cn_alias_required）：str＝字符串；list＝列表；dict＝字典；Path＝路径；int＝整数。"""
    def build_index(fs: Filesystem, tokenizer: Tokenizer, index: IndexStore, collection_path: Path, mode: str) -> IndexStats:
        if not fs.exists(collection_path):
            raise FileNotFoundError("NOT_FOUND: collection_path")  # 提前失败，避免无谓 IO（error）
        for fp in fs.listdir(collection_path):
            text: str = fs.read_text(fp, "utf-8")                 # read：以 UTF-8 读取文件（字符串）
            tokens: list[str] = tokenizer.split(text=text, max_tokens=2048)  # call：真实调用
            index.append(tokens)                                  # write：将 tokens 形成 posting，追加写入倒排索引
        return IndexStats(index_id=f"idx::{collection_path.as_posix()}", size=index.size())

    """函数：query_index —— 查询索引（只读路径）
    行为：
    1) 候选集：read: index.lookup(query) 基于倒排表获取初筛集合（可能未排序）
    2) 重排：call: ranker.score(docs, top_k)＝BM25 统计项 + 语义向量余弦相似度加权融合
    3) 返回：按相关度降序的文档 ID 列表；长度 ≤ top_k；source: repo | tests"""
    def query_index(index: IndexStore, ranker: Ranker, query: str, top_k: int = 50) -> list[str]:
        candidates: list[str] = index.lookup(query)               # read：倒排表检索
        order: list[int] = ranker.score(docs=candidates, top_k=top_k)  # call：相关性重排
        return [candidates[i] for i in order]

  generator:
    order: [banner, imports, types_aliases, deps_protocols, returns_typed_dicts, functions, examples, prompts]

  authoring_manifesto:
    - 文档即代码：产出必须可直译为 Python 源文件；保留真实标识符/调用/括号/赋值/类型注解与缩进。
    - 先中文后代码：先用中文解释“为什么/做什么/副作用/约束”，再给真实 import/def/调用/赋值/返回。
    - 调用要还原语义：每个关键调用后 1–2 行中文解释其隐藏的动作与副作用（call_expansion）。
    - 函数必须解释：每个 def 顶部用中文概述目的、输入/输出与副作用（def_explained）。
    - 显式读/写/错误：出现 IO/网络/存取/异常处，写出 read/write/call/error/source 行。
    - 术语中文化：str=字符串、int=整数、list=列表、dict=字典、Path=路径，贯穿全文。
    - Prompt 属于代码：以 python 常量内联 PROMPT_CATALOG 与 PROMPT_VARS_SCHEMA，并锚定 prompts_snapshot。
    - 单一事实源：files.path 指向的模块与本文一致；以文档为真相源（doc_is_source）。

"""文件: Kobe/WorkPlan/11.md
模块: kobe.workplan.asset_transition
同步策略: doc_is_source  ← 本文即事实源；相关实现与校验以此为准
目的: 将“资产拆解与迁移”正文改写为“中文解释 + 可直译代码”风格，并内联 Prompts、行为契约与输出结构，便于机检与生成。"""

"""导入 __future__.annotations：推迟类型名解析，便于在注解中前向引用类型名；不改变运行时行为。"""
from __future__ import annotations

"""导入 Path（路径）：以“路径”代替“字符串”表达文件系统路径，支持拼接/存在性/规范化等跨平台能力。"""
from pathlib import Path

"""从 typing 导入 Protocol（协议）、TypedDict（字典类型）、Iterable（可迭代）、Mapping（映射）：
意图：用“协议”描述依赖外形（便于注入与替换），用“字典类型”声明输出结构；集合用 Iterable/Mapping 描述。"""
from typing import Protocol, TypedDict, Iterable, Mapping

"""依赖接口外形（protocol）：
Filesystem —— 读写/遍历；Vcs —— 读取 git 状态/提交；Auditor —— 记录审计 trail。"""
class Filesystem(Protocol):
    def exists(self, path: Path) -> bool: ...
    def iterdir(self, path: Path) -> Iterable[Path]: ...

class Vcs(Protocol):
    def is_dirty(self, path: Path) -> bool: ...
    def head_commit(self) -> str: ...

class Auditor(Protocol):
    def record(self, entry: Mapping[str, str]) -> None: ...

"""返回结构：资产报告（asset_report）。removed/preserved 为字符串列表；status=clean|violation。"""
class AssetReport(TypedDict):
    removed: list[str]
    preserved: list[str]
    status: str

"""函数：call_assert_absent —— 断言目录不存在（辅助）
输入：path（字符串/路径）
行为：若路径存在返回 False，并用于触发 LegacyAssetError；否则 True。"""
def call_assert_absent(fs: Filesystem, path: Path) -> bool:
    return not fs.exists(path)

"""函数：call_record_audit —— 写入审计 trail（辅助）
输入：entry（映射）包含 path action timestamp commit。
副作用：调用 Auditor.record 写入到审计系统。"""
def call_record_audit(auditor: Auditor, entry: Mapping[str, str]) -> None:
    auditor.record(entry)  # write：审计落库；用于追踪资产迁移。

"""函数：behavior_asset_guard —— 资产拆解/迁移前置检查（CI 钩子）
MUST：
  - 在构建前扫描 removed_directories；任一存在 → 失败并提示清理步骤。
  - preserved_modules 任意目录若 git 脏（is_dirty=True）→ 阻止 release。
SHOULD：
  - 记录审计条目（asset_cleanup_summary），包含 dir/timestamp/commit。"""
def behavior_asset_guard(
    fs: Filesystem,
    vcs: Vcs,
    auditor: Auditor,
    removed_directories: list[str],
    preserved_modules: list[str],
) -> AssetReport:
    removed: list[str] = []
    preserved_dirty: list[str] = []

    for p in removed_directories:  # read：扫描遗留目录
        path = Path(p)
        if not call_assert_absent(fs, path):
            removed.append(p)

    for p in preserved_modules:  # read：检测保留模块是否 clean
        if vcs.is_dirty(Path(p)):
            preserved_dirty.append(p)

    status = "clean" if (not removed and not preserved_dirty) else "violation"

    # write：若有删除动作（此处仅示意）则记录审计；真实删除动作由流水线具体步骤执行
    if removed:
        call_record_audit(
            auditor,
            {
                "dir": ",".join(removed),
                "timestamp": "<inject at runtime>",
                "commit": vcs.head_commit(),
            },
        )

    return AssetReport(removed=removed, preserved=preserved_dirty, status=status)

"""示例（最小）：
Golden：removed=["Kobe/TelegramBot/legacy"] preserved=[] -> status="violation"
Counter：removed=[] preserved=["Kobe/Deprecated"] -> status="violation"（命中保留模块脏状态）"""
def _examples() -> None:
    return None

#@anchor:prompts_snapshot
PROMPT_CATALOG: dict = {
    "asset_guard_violation": {
        "locale": "zh-CN",
        "audience": "devops",
        "text": "发现遗留目录 {path}，阻止合并",
    },
    "asset_cleanup_summary": {
        "locale": "en-US",
        "audience": "maintainer",
        "text": "Removed {dir} at {timestamp} commit {commit}",
    },
}

PROMPT_VARS_SCHEMA: dict = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "properties": {
        "path": {"type": "string"},
        "dir": {"type": "string"},
        "timestamp": {"type": "string"},
        "commit": {"type": "string"},
    },
    "required": [],
}

