---
description: 工程化"任务执行"工作流 - 按任务清单逐步实现功能开发
version: 2.0
language: zh-CN
upstream: DevPipelineGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/verify-execution.ps1 -Json
---

# DevPiplineExcute - 任务执行工作流

## 工作流概述

**目标**：读取任务清单（Tasks.md），按顺序逐项执行开发步骤，完成功能开发。

**核心原则**：
- 严格按任务清单的阶段顺序执行
- 每完成一个 Step，验证 acceptance 是否满足
- 复用现有模块优先于重新实现
- 遵循项目规范和最佳实践

**输入**：任务清单 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/Tasks.md`  
**输出**：功能实现代码 + 执行报告

---

## 参数定义

```yaml
OUTPUT_DIR_PATH: "D:/AI_Projects/CodexFeatured/DevPlans"
COUNT_3D: "{{RUNTIME_RESOLVE}}"          # 从任务清单解析
INTENT_TITLE_2_4: "{{RUNTIME_RESOLVE}}"  # 从任务清单解析
TASKS_FILENAME: "Tasks.md"
REPORT_FILENAME: "DevExcute_Run_Report.md"
TASKS_PATH: "${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}/${TASKS_FILENAME}"
REPORT_PATH: "${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}/${REPORT_FILENAME}"
```

---

## 执行流程（DevPiplineExcute 工作流范围）

**用户输入处理**：

用户可通过命令参数传入任务清单路径、执行参数或特殊指令（如跳过某个阶段）。在继续执行前，你**必须**考虑用户输入（若不为空）。

用户输入：

$ARGUMENTS

---

### 步骤1：定位并加载任务清单

**动作**：
1. **解析用户输入**：
   → 如果 $ARGUMENTS 包含文件路径：
     * 验证路径指向 Tasks.md 文件
     * 使用该路径作为目标任务清单
   → 如果 $ARGUMENTS 包含执行参数（如 `--skip-tests`、`--stage=2`）：
     * 解析并记录执行参数
     * 在后续执行中应用参数
   → 如果 $ARGUMENTS 为空：
     * 继续自动扫描流程

2. **运行上下文获取脚本**（如果配置）：
   ```
   从仓库根目录运行 `{SCRIPT}` 并解析JSON获取：
   - TARGET_TASKS_PATH: 目标任务清单路径
   - TARGET_DIR: 任务清单所在目录
   - EXISTING_REPORT: 是否已存在执行报告
   ```
   → 如果脚本执行失败或未配置：继续手动扫描

3. **自动扫描目标任务清单**（脚本未配置时）：
   - 扫描 `${OUTPUT_DIR_PATH}` 下所有子目录
   - 查找包含 `${TASKS_FILENAME}` 的目录
   - 按目录编号倒序排列（最大编号优先）
   - 选择最近修改的 Tasks.md 作为目标
   → 如果找到多个候选：
     * 检查文件修改时间，选择最新的
     * WARN "找到多个任务清单，选择最新的: {选择的路径}"
   → 如果未找到任何任务清单：
     * ERROR "未找到任务清单，请先运行 DevPipelineGeneration 生成任务清单"

4. **读取并解析任务清单**：
   - 读取目标文件完整内容
   - 从文档头部"标识信息"行提取：
     * COUNT_3D（正则提取 `COUNT_3D=(\d{3})`）
     * INTENT_TITLE_2_4（正则提取 `INTENT_TITLE_2_4=([A-Z][a-z]+(?:[A-Z][a-z]+){1,3})`）
     * 生成时间（可选）
   → 如果标识信息缺失或格式错误：
     * ERROR "任务清单标识信息缺失或格式错误，文件: {文件路径}"
   - 设置目标目录：
     * `TARGET_DIR = dirname(目标文件路径)`
     * `REPORT_PATH = "${TARGET_DIR}/${REPORT_FILENAME}"`

5. **解析任务结构**：
   - 提取"技术决策说明"章节：
     * 复用模块清单
     * 新增依赖清单
     * 架构决策清单
   - 提取"任务清单"章节：
     * 按阶段提取所有 Step
     * 每个 Step 提取：title、sub_steps、acceptance
     * 识别并行任务标记 `[P]`
   - 提取"执行顺序说明"：
     * 阶段顺序要求
     * 依赖关系说明
   - 提取"性能验证清单"：
     * 性能指标列表

6. **验证任务清单完整性**：
   - 验证必需章节存在
     → 如果缺少：ERROR "任务清单缺少必需章节: {章节名}"
   - 验证至少包含一个阶段
     → 如果无阶段：ERROR "任务清单无可执行阶段"
   - 验证每个 Step 包含 acceptance
     → 如果缺少：WARN "Step {编号} 缺少验收标准"

7. **更新进度**：任务清单加载与解析完成

**输出**：
- TARGET_DIR（任务清单所在目录）
- TASKS_PATH（任务清单完整路径）
- REPORT_PATH（执行报告输出路径）
- COUNT_3D、INTENT_TITLE_2_4（从任务清单提取）
- 技术决策清单（已解析）
- 任务阶段列表（已解析）
- 性能验证清单（已解析）

---

### 步骤2：加载项目规范与上下文

**动作**：
1. **运行代码库结构分析脚本**：
   ```python
   运行 CodexFeatured/Scripts/CodebaseStructure.py
   ```
   → 如果脚本执行失败：WARN "代码库分析脚本执行失败，基于现有文档进行分析"

2. **读取项目规范**：
   - 读取 `CodexFeatured/Common/BackendConstitution.yaml`：
     * 加载所有 `mandates` 强制要求
     * 加载所有 `prohibitions` 禁止项
     * 加载技术栈定义
   - 读取 `CodexFeatured/Common/CodeCommentStandard.yaml`（如果存在）：
     * 加载注释风格要求
     * 加载 Docstring 模板
   - 读取 `CodexFeatured/Common/BestPractise.yaml`（如果存在）：
     * 加载最佳实践要点
     * 索引官方文档链接

3. **构建规范检查清单**：
   - 对于每个强制要求，构建检查项：
     * 检查项描述
     * 检查方法（如代码扫描、配置验证）
   - 对于每个禁止项，构建检查项：
     * 检查项描述
     * 检查方法

4. **调研官方最佳实践**：
   - 从步骤1的技术决策清单中提取新增依赖
   - 对每个新增依赖：
     * 访问官方文档链接（从技术决策清单获取）
     * 浏览快速开始/最佳实践章节
     * 记录关键要点（初始化、配置、常见陷阱）
   → 如果官方文档不可访问：
     * WARN "官方文档不可访问: {依赖名}，将基于社区实践"

5. **调研社区最佳实践**（可选）：
   - 搜索 GitHub/StackOverflow 寻找生产级实现参考
   - 识别常见问题与解决方案
   - 记录关键要点

6. **更新进度**：项目规范加载完成

**输出**：
- 强制要求清单
- 禁止项清单
- 注释风格要求
- 最佳实践要点（官方 + 社区）
- 规范检查清单

---

### 步骤3：按阶段执行任务

*门控：每个阶段完成后必须验证 acceptance，通过后才能进入下一阶段*

**动作**：
1. **初始化执行状态**：
   - 创建执行记录：
     ```json
     {
       "start_time": "{YYYY-MM-DD HH:mm:ss}",
       "stages": {},
       "errors": [],
       "warnings": []
     }
     ```

2. **按阶段顺序执行**：

   **对于每个阶段**（阶段0 → 阶段N）：

   a. **阶段开始**：
      - 记录阶段开始时间
      - 输出提示：
        ```markdown
        ## 开始执行：阶段{N}
        阶段名称：{阶段名称}
        任务数量：{Step数量}
        开始时间：{YYYY-MM-DD HH:mm:ss}
        ```

   b. **执行阶段内的所有 Step**：

      **对于每个 Step**：

      i. **Step 开始**：
         - 记录 Step 开始时间
         - 输出提示：
           ```markdown
           ### Step {编号}：{title}
           ```

      ii. **执行 sub_steps**：
         - 识别并行任务 `[P]`：
           * 如果所有 sub_steps 都标记 `[P]`：可以批量执行
           * 如果混合标记：先执行 `[P]` 的，再执行无标记的
         - 对于每个 sub_step：
           * 解读 sub_step 内容，理解要做什么
           * 从技术决策清单中查找相关引用（复用模块、新增依赖）
           * 执行具体操作（创建文件、编写函数、配置设置）
           * 应用规范要求（注释风格、命名规范、类型注解）
         → 如果 sub_step 执行失败：
           * 记录错误详情
           * 尝试理解失败原因
           * 如果可重试：重试1-2次
           * 如果无法继续：ERROR "Step {编号} 执行失败: {错误详情}"

      iii. **验证 acceptance**：
         - 读取该 Step 的 acceptance 清单
         - 对每个验收条件进行检查：
           * 文件存在性检查（如"parser.py 文件存在"）
           * 函数可调用性检查（如"parse_sql_file 函数可调用"）
           * 类型检查（如"返回值类型为 (list, list)"）
           * 文档检查（如"Docstring 完整"）
           * 测试通过检查（如果涉及测试）
         → 如果任何验收条件不满足：
           * FAIL "Step {编号} 验收失败: {失败条件}"
           * 记录失败详情
           * 尝试修正（最多2次）
           * 如果2次后仍失败：ERROR "Step {编号} 验收失败，无法继续"

      iv. **Step 完成**：
         - 记录 Step 完成时间
         - 记录 Step 耗时
         - 标记 Step 状态为"已完成"
         - 输出提示：
           ```markdown
           ### Step {编号} 完成
           耗时：{耗时}
           验收：通过
           ```

   c. **阶段完成**：
      - 记录阶段完成时间
      - 记录阶段耗时
      - 输出提示：
        ```markdown
        ## 阶段{N} 完成
        任务数量：{Step数量}
        完成数量：{完成数量}
        耗时：{耗时}
        ```

   d. **阶段门控验证**（重要）：
      - 验证该阶段的所有 Step 都已完成
      - 验证该阶段的所有 acceptance 都已通过
      - 验证该阶段产出的文件/函数/配置都符合规范
        → 如果门控失败：
          * FAIL "阶段{N} 门控验证失败: {失败详情}"
          * 不允许进入下一阶段
          * 修正问题后重新验证
      - 更新进度：阶段{N} 门控通过

3. **处理并行任务**：
   - 对于标记 `[P]` 的 sub_steps：
     * 验证确实可以并行（不依赖相同文件）
     * 如果可以并行：批量执行
     * 如果存在隐含依赖：WARN "并行任务可能存在依赖，建议顺序执行"

4. **应用最佳实践**：
   - 在编写代码时，应用步骤2加载的最佳实践要点
   - 示例：
     * 使用 `async/await` 进行异步I/O
     * 使用 Pydantic v2 进行数据验证
     * 使用 `RichLogger` 记录关键事件
     * 遵循注释风格规范

5. **更新进度**：所有阶段执行完成

**输出**：
- 功能实现代码（在项目目录中）
- 执行记录（JSON格式，包含每个Step的状态）
- 错误与警告列表

---

### 步骤4：规范对齐验证（质量门控）

*门控：所有任务执行完成后，必须验证产出符合项目规范*

**动作**：
1. **读取生成的代码文件**：
   - 从执行记录中提取所有新建/修改的文件
   - 读取文件内容

2. **执行规范检查**：

   **检查1：技术栈约束对齐**
   - 验证所有代码符合项目约束：
     * Python 版本 ≥ 3.10
     * 使用异步I/O（async/await）
     * 使用 Pydantic v2 进行验证
     * 统一使用 RichLogger 而非 print()
   → 如果违反约束：FAIL "代码违反技术栈约束: {违反详情}"

   **检查2：禁止项检查**
   - 扫描代码是否包含禁止操作：
     * 长时间阻塞型同步 I/O
     * 全局线程创建
     * 生产凭据硬编码
     * 绕过 Celery 直接执行任务
   → 如果发现禁止项：FAIL "代码包含禁止操作: {禁止项详情}"

   **检查3：注释规范检查**
   - 验证函数 Docstring 完整性：
     * 函数描述
     * 参数说明（含类型）
     * 返回值说明（含类型）
     * 异常说明（如适用）
   → 如果注释不完整：FAIL "函数 {函数名} 注释不完整"

   **检查4：最佳实践对齐**
   - 验证代码遵循官方最佳实践：
     * 依赖库的推荐用法
     * 错误处理模式
     * 资源管理（如 async with）
   → 如果不符合最佳实践：WARN "代码不符合最佳实践: {详情}"

3. **处理验证结果**：
   → 如果所有检查通过：
     * 记录验证成功
     * 更新进度：规范对齐验证通过
     * 继续步骤5
   → 如果任何检查失败：
     * 记录失败详情
     * 修正代码
     * 重新执行验证（最多3轮）
     * 如果3轮后仍失败：ERROR "规范对齐验证失败，失败详情: {详情列表}"

4. **更新进度**：规范对齐验证通过

---

### 步骤5：性能验证（如适用）

**动作**：
1. **读取性能验证清单**：
   - 从步骤1解析的性能验证清单中提取指标
   - 示例：
     * 响应时间 < 500ms
     * 吞吐量 > 1000条/秒
     * 并发支持 ≥ 100

2. **执行性能验证**：
   → 如果需求文档有明确性能要求：
     * 构建性能测试场景
     * 执行性能测试
     * 记录测试结果
     * 对比性能指标
       → 如果不满足性能要求：
         * FAIL "性能验证失败: {指标} 不满足要求，实际值: {实际值}，要求: {要求值}"
         * 分析性能瓶颈
         * 优化代码
         * 重新测试
   → 如果需求文档无明确性能要求：
     * 跳过性能验证
     * 输出提示："无明确性能要求，跳过性能验证"

3. **更新进度**：性能验证完成

**输出**：
- 性能测试结果
- 性能指标对比

---

### 步骤6：生成执行报告

**动作**：
1. **汇总执行统计**：
   - 执行时间：{开始时间} - {结束时间}
   - 总耗时：{总耗时}
   - 阶段统计：
     * 阶段数量：{数量}
     * 完成阶段数量：{数量}
   - 任务统计：
     * 总 Step 数量：{数量}
     * 完成 Step 数量：{数量}
     * 失败 Step 数量：{数量}
   - 文件统计：
     * 新建文件数量：{数量}
     * 修改文件数量：{数量}
     * 新增代码行数：{数量}
   - 错误与警告：
     * 错误数量：{数量}
     * 警告数量：{数量}

2. **生成报告文档**：

   ```markdown
   # 任务执行报告：{功能名称}

   标识信息：INTENT_TITLE_2_4={INTENT_TITLE_2_4}；COUNT_3D={COUNT_3D}；执行时间={YYYY-MM-DD HH:mm:ss}
   任务清单：{TASKS_PATH}
   输出路径：{REPORT_PATH}

   ---

   ## 执行摘要

   **执行状态**：成功/失败
   **执行时间**：{开始时间} - {结束时间}
   **总耗时**：{总耗时}

   **任务统计**：
   - 阶段数量：{数量}
   - 完成阶段：{数量}/{总数}
   - 总 Step 数量：{数量}
   - 完成 Step：{数量}/{总数}
   - 失败 Step：{数量}

   **代码统计**：
   - 新建文件：{数量}
   - 修改文件：{数量}
   - 新增代码行数：{数量}

   **质量指标**：
   - 规范对齐检查：通过/失败
   - 性能验证：通过/失败/跳过
   - 错误数量：{数量}
   - 警告数量：{数量}

   ---

   ## 阶段执行详情

   ### 阶段0：{阶段名称}
   - 状态：完成
   - 耗时：{耗时}
   - Step数量：{数量}
   - 完成Step：{数量}

   #### Step 0.1：{title}
   - 状态：完成
   - 耗时：{耗时}
   - 验收：通过
   - 产出：{产出文件列表}

   [重复其他阶段和Step]

   ---

   ## 文件变更清单

   ### 新建文件
   - `{文件路径1}` - {文件描述}
   - `{文件路径2}` - {文件描述}

   ### 修改文件
   - `{文件路径1}` - {修改描述}
   - `{文件路径2}` - {修改描述}

   ---

   ## 规范检查报告

   ### 技术栈约束对齐
   - [x] Python 版本 ≥ 3.10
   - [x] 使用异步I/O
   - [x] 使用 Pydantic v2
   - [x] 统一使用 RichLogger

   ### 禁止项检查
   - [x] 无长时间阻塞型同步 I/O
   - [x] 无全局线程创建
   - [x] 无生产凭据硬编码
   - [x] 无绕过 Celery 直接执行任务

   ### 注释规范检查
   - [x] 所有函数包含 Docstring
   - [x] Docstring 包含参数说明
   - [x] Docstring 包含返回值说明

   ---

   ## 性能验证报告

   [如果执行了性能验证]
   | 性能指标 | 要求值 | 实际值 | 状态 |
   |---------|-------|-------|------|
   | 响应时间 | < 500ms | 320ms | 通过 |
   | 吞吐量 | > 1000条/秒 | 1500条/秒 | 通过 |

   ---

   ## 错误与警告

   ### 错误列表
   [如果有错误]
   - 错误1：{错误描述}
   - 错误2：{错误描述}

   ### 警告列表
   [如果有警告]
   - 警告1：{警告描述}
   - 警告2：{警告描述}

   ---

   ## 下一步建议

   [基于执行结果提供建议]
   - 建议1：{建议描述}
   - 建议2：{建议描述}

   ---

   **工作流版本**：2.0 | **执行时间**：{YYYY-MM-DD HH:mm:ss}
   ```

3. **写入报告文件**：
   ```
   写入文件：${REPORT_PATH}
   编码：UTF-8（无BOM）
   ```

4. **更新进度**：执行报告生成完成

**输出文件**：`${REPORT_PATH}`

---

### 步骤7：完成与输出

**动作**：
1. **输出执行摘要**：
   ```markdown
   ## 任务执行完成

   **输出报告**：{REPORT_PATH}
   **编号**：{COUNT_3D}
   **意图标识**：{INTENT_TITLE_2_4}
   **执行时间**：{YYYY-MM-DD HH:mm:ss}

   **执行统计**：
   - 完成阶段：{数量}/{总数}
   - 完成 Step：{数量}/{总数}
   - 新建文件：{数量}
   - 修改文件：{数量}

   **质量状态**：
   - 规范对齐：通过
   - 性能验证：通过/跳过

   **下一步**：
   请查看执行报告了解详细信息。如有需要，可运行测试验证功能正确性。
   ```

2. **更新进度**：工作流执行完成

---

## 进度跟踪

*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 步骤1：任务清单加载与解析完成
- [ ] 步骤2：项目规范加载完成
- [ ] 步骤3：所有阶段执行完成
- [ ] 步骤4：规范对齐验证通过（门控）
- [ ] 步骤5：性能验证完成
- [ ] 步骤6：执行报告生成完成
- [ ] 步骤7：工作流执行完成

**阶段执行状态**（动态更新）：
- [ ] 阶段0：{阶段名称} - 完成
- [ ] 阶段1：{阶段名称} - 完成
- [ ] 阶段2：{阶段名称} - 完成
- [ ] ...

**质量门控状态**：
- [ ] 每阶段门控验证：通过
- [ ] 规范对齐检查：通过
- [ ] 性能验证：通过/跳过

---

## 验收标准（Acceptance Criteria）

**执行完整性**：
- [ ] 所有阶段按顺序执行完成
- [ ] 所有 Step 执行完成
- [ ] 所有 acceptance 验证通过
- [ ] 无未解决的错误

**代码质量**：
- [ ] 所有代码符合技术栈约束
- [ ] 无违反禁止项
- [ ] 所有函数包含完整 Docstring
- [ ] 代码遵循最佳实践

**性能要求**（如适用）：
- [ ] 所有性能指标满足要求
- [ ] 性能测试通过

**文档完整性**：
- [ ] 执行报告生成
- [ ] 文件变更清单完整
- [ ] 错误与警告记录完整

---

## 错误处理约定

**ERROR 级别**（终止执行）：
- 任务清单未找到或标识信息缺失
- Step 执行失败（2次重试后仍失败）
- Step 验收失败（2次修正后仍失败）
- 阶段门控验证失败
- 规范对齐验证失败（3轮后仍未通过）

**WARN 级别**（记录警告但继续）：
- 代码库分析脚本执行失败
- Step 缺少验收标准
- 并行任务可能存在依赖
- 代码不符合最佳实践（非强制）

---

## 规范引用

**项目规范**：
- `CodexFeatured/Common/BackendConstitution.yaml` - 技术栈约束与禁止项
- `CodexFeatured/Common/CodeCommentStandard.yaml` - 注释风格要求
- `CodexFeatured/Common/BestPractise.yaml` - 最佳实践指南
- `CodexFeatured/Common/CodebaseStructure.yaml` - 项目结构文档

**工作流版本**：2.0 | **最后更新**：2025-10-11

---

*基于 SpecKit 工程实践 v2.1.1 - 融合用户业务理解与工程级执行控制*

