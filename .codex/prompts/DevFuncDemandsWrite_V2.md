---
description: 工程化"开发需求文档撰写"工作流 - 从用户诉求到结构化需求文档
version: 2.0
language: zh-CN
downstream: DevPipelineGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/get-demand-context.ps1 -Json
---

# DevFuncDemandsWrite - 需求文档生成工作流

## 工作流概述

**目标**：将用户的功能诉求转化为完整、无歧义、可被 DevPipelineGeneration 工作流消费的结构化需求文档。

**核心原则**：
- 聚焦"要做什么"，不涉及"怎么做"
- 主动补足用户未明确的需求细节
- 基于场景分析进行合理假设
- 确保需求可验收、可转化为验收标准

**输入**：用户提示词文件 `CodexFeatured/DevFuncDemandsWrite/PromptDraft.md`  
**输出**：结构化需求文档 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DemandDescription.md`

---

## 参数定义

```yaml
OUTPUT_DIR_PATH: "D:/AI_Projects/CodexFeatured/DevPlans"
COUNT_3D: "{{RUNTIME_GENERATE}}"         # 由脚本动态生成
INTENT_TITLE_2_4: "{{RUNTIME_GENERATE}}" # 由 AI 从意图提取
SUBDIR_NAME: "${COUNT_3D}_${INTENT_TITLE_2_4}"
FILENAME: "DemandDescription.md"
OUTPUT_PATH: "${OUTPUT_DIR_PATH}/${SUBDIR_NAME}/${FILENAME}"
```

**命名规则验证**：
- `COUNT_3D`: 正则 `^\d{3}$`，范围 001-999
- `INTENT_TITLE_2_4`: 正则 `^[A-Z][a-z]+(?:[A-Z][a-z]+){1,3}$`，2-4个PascalCase词，每词 ≥ 3字符

---

## 执行流程（DevFuncDemandsWrite 工作流范围）

**用户输入处理**：

用户输入可通过命令参数传入或直接在提示词中提供。在继续执行前，你**必须**考虑用户输入（若不为空）。

用户输入：

$ARGUMENTS

---

### 步骤1：加载并验证用户提示词

**动作**：
1. 读取用户提示词文件 `CodexFeatured/DevFuncDemandsWrite/PromptDraft.md`
   → 如果文件不存在：ERROR "提示词文件未找到，路径: CodexFeatured/DevFuncDemandsWrite/PromptDraft.md"
   → 如果文件为空（<50字符）：ERROR "提示词内容为空或过短，请先撰写需求描述"

2. 解析用户核心诉求：
   - 提取主要功能域关键词（2-5个名词/动词短语）
   - 识别显式参数：
     * URL（需访问的目标系统）
     * 文件路径（数据源/配置文件）
     * 数据源标识（数据库/API/第三方服务）
     * 目标系统名称
   - 提取技术约束与特殊要求
   - 识别业务场景线索（行业/领域/用户角色）

3. 从命令参数 `$ARGUMENTS` 中补充信息：
   → 如果 $ARGUMENTS 非空：
     * 优先使用 $ARGUMENTS 中提供的参数值
     * 将 $ARGUMENTS 与提示词内容合并理解
     * 如有冲突，以 $ARGUMENTS 为准并记录差异
   → 如果 $ARGUMENTS 为空：
     * 完全基于提示词文件内容进行分析

4. **验证必需信息完整性**：
   → 如果核心功能域无法识别：ERROR "无法从提示词中识别核心功能需求，请提供更清晰的功能描述"
   → 如果提供的URL无法访问：WARN "目标URL不可访问，将基于功能域标准做法进行假设"

5. **更新进度**：用户意图解析完成

**输出**：
- 用户核心诉求摘要（100字内）
- 显式参数清单
- 技术约束清单
- 业务场景识别结果

---

### 步骤2：生成工作目录命名

**动作**：
1. **运行上下文获取脚本**（如果配置）：
   ```
   从仓库根目录运行 `{SCRIPT}` 并解析JSON获取：
   - EXISTING_PLANS: 现有计划目录列表
   - NEXT_COUNT: 建议的下一个编号
   - PROJECT_ROOT: 项目根路径
   ```
   → 如果脚本执行失败或未配置：继续手动扫描

2. **生成 COUNT_3D**：
   - 扫描 `${OUTPUT_DIR_PATH}` 获取所有子目录名
   - 提取匹配 `^\d{3}_.*` 格式的目录编号
   - 计算 `COUNT_3D = max(现有编号) + 1`，左填充零至3位
   → 如果无现有目录或解析失败：`COUNT_3D = "001"`
   → 如果计算值已存在（目录冲突）：递增直到找到可用编号
   - 验证生成值匹配正则 `^\d{3}$`
     → 如果验证失败：ERROR "编号生成异常，当前值: {COUNT_3D}"

3. **生成 INTENT_TITLE_2_4**：
   - 从步骤1的核心诉求中提取 2-4 个英文核心词：
     * 优先选择名词和动词
     * 移除停用词：the, a, an, of, for, with, and, to, in, at, by, from
     * 同义词归一化（如 create → Create, setup → Setup）
   - 转换为 PascalCase 格式：
     * 每个词首字母大写
     * 去除所有分隔符（空格、下划线、连字符）
     * 确保每个词 ≥ 3 字符
   - 验证结果匹配正则 `^[A-Z][a-z]+(?:[A-Z][a-z]+){1,3}$`
     → 如果验证失败或语义不明确：使用 "GeneralTask" 作为兜底值
   - 示例映射：
     * "用户注册登录" → "UserRegistrationLogin"
     * "数据导入与校验" → "DataImportValidation"
     * "支付网关对接" → "PaymentGatewayIntegration"

4. **构造输出路径**：
   - `SUBDIR_NAME = "${COUNT_3D}_${INTENT_TITLE_2_4}"`
   - `OUTPUT_PATH = "${OUTPUT_DIR_PATH}/${SUBDIR_NAME}/${FILENAME}"`
   - 验证输出目录不存在
     → 如果目录已存在：ERROR "目标目录已存在: {OUTPUT_PATH}，请检查编号冲突"

5. **更新进度**：命名生成完成

**输出**：
- COUNT_3D（如 "004"）
- INTENT_TITLE_2_4（如 "UserProfilingFieldClassification"）
- OUTPUT_PATH（完整输出路径）

---

### 步骤3：加载项目现状与规范

**动作**：
1. **运行代码库结构分析脚本**：
   ```python
   运行 CodexFeatured/Scripts/CodebaseStructure.py
   ```
   → 如果脚本执行失败：WARN "代码库分析脚本执行失败，将基于现有文档进行分析"

2. **读取项目结构文档**：
   - 读取 `CodexFeatured/Common/CodebaseStructure.yaml`
   - 读取 `Kobe/index.yaml` 作为入口
   - 按 `relation` 字段自顶向下遍历所有 `index.yaml` 文件
     → 如果某个 index.yaml 不存在：WARN "索引文件缺失: {path}，跳过该分支"
   
3. **构建项目能力图谱**：
   - **已实现功能模块**：
     * 模块名称与职责边界
     * 对外API与调用方式
     * 使用示例与文档链接
   - **基础设施现状**：
     * 数据库：类型、连接方式、容量
     * 缓存：Redis配置、命名规范
     * 消息队列：RabbitMQ配置、交换机/队列定义
     * 存储：文件存储、对象存储配置
   - **可复用组件**：
     * 工具函数：路径、功能、使用示例
     * 中间件：路径、用途、配置方式
     * 装饰器：路径、功能、参数说明
   - **项目架构模式**：
     * 目录组织规范
     * 模块依赖关系
     * 命名规范与约定

4. **加载规范与约束**：
   - 读取 `CodexFeatured/Common/BackendConstitution.yaml`：
     * 提取所有 `mandates` 强制要求
     * 提取所有 `prohibitions` 禁止项
     * 识别技术栈约束（运行时、框架、存储）
   - 读取 `CodexFeatured/Common/BestPractise.yaml`（如果存在）：
     * 索引官方文档链接
     * 提取最佳实践要点

5. **构建规范决策树**：
   - 对于每个技术选型点（如异步I/O、消息队列、缓存策略）：
     * 约束条件
     * 推荐方案
     * 禁用方案与理由

6. **更新进度**：项目上下文加载完成

**输出**：
- 项目能力图谱
- 技术栈约束清单
- 基础设施清单
- 可复用组件清单
- 架构模式说明
- 规范决策树

---

### 步骤4：场景深度分析与需求补足

**动作**：
1. **识别功能域**：
   - 基于步骤1的用户核心诉求，推断功能域类别
   - 功能域识别包含：
     * 主要功能类型（如数据采集、用户认证、报表生成）
     * 业务价值（为什么需要这个功能）
     * 典型应用场景（在什么情况下使用）

2. **构建需求维度清单**：
   - 从业务视角提取该功能域的标准需求维度（非技术实现维度）
   - 需求维度必须覆盖：
     * **功能范围**：业务边界、覆盖场景、包含/排除的功能点
     * **数据需求**：数据来源、数据类型、数据结构、数据量级
     * **触发条件**：业务触发时机、执行频率、触发方式
     * **性能要求**：响应时间要求、吞吐量要求、并发量级、资源约束
     * **质量要求**：准确性要求、完整性要求、一致性要求、可用性要求
     * **异常场景**：失败定义、重试要求、降级策略、补偿机制
     * **安全要求**：数据敏感性、访问控制要求、审计要求
     * **可观测性**：需记录的关键事件、需监控的业务指标

3. **主动获取外部信息**：
   → 如果用户提供URL：
     * 尝试访问并分析目标系统的业务特征
     * 识别内容类型、数据结构、业务规则
     * 如果访问失败：WARN "URL不可访问，将基于功能域标准做法假设"
   → 如果用户提供API文档：
     * 解析业务接口规范
     * 识别业务实体、数据格式、业务约束
   → 如果用户提供数据样本：
     * 分析业务数据特征
     * 识别业务字段、数据关系、业务规则
   → 如果用户未提供明确目标：
     * 基于功能域的典型业务场景进行合理假设

4. **为每个需求维度补足完整描述**：
   - 补足依据优先级：外部分析结果 > 功能域标准做法 > 项目历史需求 > 合理假设
   - 每个需求维度必须包含：
     1. **需求描述**（清晰描述业务要求，使用业务语言而非技术术语）
     2. **补足理由**（说明为何如此假设，基于什么业务逻辑或场景分析）
     3. **量化指标**（若适用，给出具体的业务指标值）
   - 需求描述必须满足：
     * **业务导向**：使用业务术语（如"获取文章内容"而非"爬取HTML"）
     * **需求层面**：描述要达到的目标（如"响应时间<500ms"而非"使用异步框架"）
     * **可验收性**：需求可转化为验收标准（如"支持100并发"而非"性能要好"）
     * **禁止技术实现**：不涉及具体技术选型（禁止"使用httpx"、"并发20"等实现细节）

5. **基于项目约束过滤不可行需求**：
   - 从步骤3的规范决策树中提取约束
   - 对每个需求描述验证：
     → 如果需求与项目约束冲突：
       * 调整需求描述或标注约束限制
       * 在需求描述中说明项目约束的影响
       * 示例："需使用异步I/O，不支持阻塞操作（项目约束）"
     → 如果需求不可行（违反禁止项）：
       * WARN "需求 {需求描述} 与项目禁止项冲突: {禁止项}"
       * 提供替代方案建议

6. **验证需求完整性**：
   - 验证所有需求维度均已覆盖
     → 如果某维度未覆盖：ERROR "需求维度 {维度名} 未填写，请补充"
   - 验证所有需求描述清晰且可验收
     → 如果需求描述模糊：ERROR "需求描述不明确: {需求描述}，请量化或细化"
   - 验证需求不与项目约束冲突
   - 验证需求描述不含技术实现细节
     → 如果发现技术术语：ERROR "需求描述中包含技术实现细节: {技术术语}，请改为业务描述"

7. **更新进度**：需求分析与补足完成

**输出**：
- 功能域识别结果
- 需求维度清单（8个维度）
- 外部分析报告（如适用）
- 完整需求描述（每个维度）
- 项目约束影响说明
- 量化指标汇总

---

### 步骤5：生成完整需求文档

**动作**：
1. **创建输出目录**：
   ```
   创建目录：${OUTPUT_DIR_PATH}/${SUBDIR_NAME}
   ```
   → 如果目录已存在：ERROR "目标目录已存在，可能存在编号冲突"

2. **生成文档内容**（按以下结构）：

   **文档头部**（标识信息）：
   ```markdown
   # 开发需求文档：{功能名称}

   标识信息：INTENT_TITLE_2_4={INTENT_TITLE_2_4}；COUNT_3D={COUNT_3D}；生成时间={YYYY-MM-DD HH:mm:ss}
   输出路径（模板）：{OUTPUT_PATH}
   ```

   **第1节：项目背景与目标**
   - 背景说明（为什么需要这个功能）
   - 目标陈述（要达到什么效果）
   - 受众识别（谁会使用这个文档）
   - 非技术目标（业务目标而非技术指标）

   **第2节：业务场景分析**
   - 典型场景描述（3-5个具体场景）
   - 输入与输出说明
   - 运行方式与频率
   - 边界设定（什么不做）

   **第3节：功能需求描述**
   - 从步骤4的需求维度中提取"功能范围"
   - 按业务流程组织功能点
   - 每个功能点包含：
     * 功能描述（业务语言）
     * 业务价值（为什么需要）
     * 覆盖场景（在哪些情况下使用）

   **第4节：数据需求描述**
   - 从步骤4的需求维度中提取"数据需求"
   - 数据来源说明
   - 数据类型与结构（业务视角）
   - 数据量级估算
   - 数据留存与可追溯要求

   **第5节：性能与质量要求**
   - 从步骤4的需求维度中提取"性能要求"和"质量要求"
   - 性能指标（响应时间、吞吐量、并发量）
   - 质量指标（准确性、完整性、可用性）
   - 所有指标必须量化

   **第6节：异常场景与边界条件**
   - 从步骤4的需求维度中提取"异常场景"
   - 列举可能的异常情况
   - 每个异常的处理要求（重试、降级、补偿）
   - 边界条件定义

   **第7节：安全与合规要求**
   - 从步骤4的需求维度中提取"安全要求"
   - 数据敏感性分级
   - 访问控制要求
   - 隐私保护要求
   - 审计留痕要求

   **第8节：可观测性要求**
   - 从步骤4的需求维度中提取"可观测性"
   - 需记录的关键业务事件
   - 需监控的业务指标
   - 运行报告要求

   **第9节：范围与非目标**
   - 明确范围边界
   - 列举非目标（不做什么）

   **第10节：项目约束说明**
   - 从步骤3的技术栈约束清单中提取
   - 说明约束对需求的影响
   - 路径约束说明（输入/输出/中间文件路径）

   **第11节：交付与验收标准**
   - 交付物清单（文档、代码、配置）
   - 验收清单（可测试/可验证的条件）

3. **写入文件**：
   ```
   写入文件：${OUTPUT_PATH}
   编码：UTF-8（无BOM）
   ```

4. **更新进度**：需求文档生成完成

**输出文件**：`${OUTPUT_PATH}`

---

### 步骤6：规范对齐验证（质量门控）

*门控：必须在输出文档前通过。最多尝试3轮修正。*

**动作**：
1. **读取约束源**：
   - 重新加载 `CodexFeatured/Common/BackendConstitution.yaml`
   - 重新加载 `CodexFeatured/Common/BestPractise.yaml`（如果存在）
   - 读取本工作流的 `acceptance` 标准

2. **读取生成的文档**：
   - 读取 `${OUTPUT_PATH}` 的完整内容

3. **执行验证检查**：

   **检查1：结构完整性**
   - 验证文档包含所有必需章节（第1-11节）
   → 如果缺少章节：ERROR "文档缺少必需章节: {章节名}"

   **检查2：业务语言规范**
   - 扫描"功能需求描述"章节，识别技术术语：
     * 库名/框架名（如 FastAPI、httpx、Celery）
     * 技术参数（如 worker数量、线程池大小）
     * 实现细节（如"使用装饰器"、"创建中间件"）
   → 如果发现技术术语：FAIL "功能需求描述包含技术实现细节: {技术术语列表}"

   **检查3：数据需求描述规范**
   - 扫描"数据需求描述"章节，识别存储技术：
     * 数据库名称（如 MongoDB、Redis）
     * 存储方案（如"存入数据库"、"写入缓存"）
   → 如果发现存储技术：FAIL "数据需求描述包含存储技术细节: {技术术语列表}"

   **检查4：性能要求可验收性**
   - 扫描"性能与质量要求"章节：
     * 验证所有性能指标已量化（含数值和单位）
     * 验证没有模糊描述（如"性能要好"、"尽可能快"）
   → 如果发现模糊描述：FAIL "性能要求包含非量化指标: {模糊描述列表}"
   → 如果发现实现手段：FAIL "性能要求包含实现细节: {实现手段列表}"

   **检查5：项目约束对齐**
   - 对比需求描述与项目约束（从步骤3加载）：
     * 验证需求不违反禁止项
     * 验证需求符合强制要求
   → 如果发现冲突：FAIL "需求与项目约束冲突: {冲突详情}"

   **检查6：命名规则验证**
   - 验证 INTENT_TITLE_2_4 匹配正则 `^[A-Z][a-z]+(?:[A-Z][a-z]+){1,3}$`
   - 验证 COUNT_3D 匹配正则 `^\d{3}$`
   - 验证文档中的标识信息与生成值一致
   → 如果验证失败：FAIL "命名规则验证失败: {错误详情}"

   **检查7：下游可消费性**
   - 验证文档为 DevPipelineGeneration 提供充分的需求输入：
     * 功能需求是否完整且可拆解
     * 数据需求是否明确且可建模
     * 性能要求是否可转化为技术指标
   → 如果不满足：FAIL "文档不满足下游工作流消费要求: {缺失项}"

4. **处理验证结果**：
   → 如果所有检查通过：
     * 记录验证成功
     * 更新进度：质量门控通过
     * 继续步骤7
   → 如果任何检查失败：
     * 记录失败详情
     * 修正文档内容
     * 重新写入 `${OUTPUT_PATH}`
     * 重新执行验证（最多3轮）
     * 如果3轮后仍失败：ERROR "质量门控验证失败，失败详情: {详情列表}"

5. **更新进度**：质量门控验证通过

---

### 步骤7：完成与报告

**动作**：
1. **生成执行报告**：
   - 执行时间：{开始时间} - {结束时间}
   - 耗时统计：{总耗时}、{各步骤耗时}
   - 生成文件：{OUTPUT_PATH}
   - 文件大小：{文件大小}
   - 质量指标：
     * 需求维度覆盖数：8/8
     * 量化指标数量：{数量}
     * 验证轮次：{轮次}/3

2. **输出报告**：
   ```markdown
   ## 需求文档生成完成

   **输出文件**：{OUTPUT_PATH}
   **编号**：{COUNT_3D}
   **意图标识**：{INTENT_TITLE_2_4}
   **生成时间**：{YYYY-MM-DD HH:mm:ss}

   **质量指标**：
   - 需求维度覆盖：8/8
   - 量化指标数量：{数量}
   - 验证轮次：{轮次}/3

   **下一步**：
   请使用 DevPipelineGeneration 工作流处理此需求文档，生成技术实现任务清单。
   ```

3. **更新进度**：工作流执行完成

---

## 进度跟踪

*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 步骤1：用户提示词加载与验证完成
- [ ] 步骤2：工作目录命名生成完成
- [ ] 步骤3：项目上下文加载完成
- [ ] 步骤4：需求分析与补足完成
- [ ] 步骤5：需求文档生成完成
- [ ] 步骤6：质量门控验证通过
- [ ] 步骤7：工作流执行完成

**质量门控状态**：
- [ ] 结构完整性检查：通过
- [ ] 业务语言规范检查：通过
- [ ] 数据需求描述规范检查：通过
- [ ] 性能要求可验收性检查：通过
- [ ] 项目约束对齐检查：通过
- [ ] 命名规则验证：通过
- [ ] 下游可消费性验证：通过

---

## 验收标准（Acceptance Criteria）

**输出文件要求**：
- [ ] 输出路径符合 `${OUTPUT_DIR_PATH}/${SUBDIR_NAME}/${FILENAME}`
- [ ] 文件编码为 UTF-8（无BOM）
- [ ] 文件大小 > 5KB（确保内容充实）

**文档结构要求**：
- [ ] 包含所有11个必需章节
- [ ] 每章节内容完整且结构化清晰
- [ ] 标识信息准确（COUNT_3D、INTENT_TITLE_2_4、生成时间）

**业务语言规范**：
- [ ] "功能需求描述"章节使用业务语言，不含技术实现细节
- [ ] "数据需求描述"章节描述业务数据特征，不涉及存储技术
- [ ] "性能与质量要求"章节给出量化指标，不涉及实现手段

**可验收性要求**：
- [ ] 所有需求描述可转化为验收标准（可测试/可验证）
- [ ] 所有性能指标已量化（含数值和单位）
- [ ] 所有功能点明确定义（无歧义）

**项目约束对齐**：
- [ ] 所有需求不违反 `BackendConstitution.yaml` 的禁止项
- [ ] 所有需求符合项目强制要求
- [ ] 约束影响已在文档中说明

**命名规范**：
- [ ] INTENT_TITLE_2_4 匹配正则 `^[A-Z][a-z]+(?:[A-Z][a-z]+){1,3}$`
- [ ] INTENT_TITLE_2_4 真实反映任务意图（不使用"InitialSetup"等通用值）
- [ ] COUNT_3D 匹配正则 `^\d{3}$`

**下游工作流可消费性**：
- [ ] DevPipelineGeneration 可基于此文档进行技术选型和实现拆解
- [ ] 文档不包含技术实现决策，为下游保留技术选型空间
- [ ] 文档完整性：包含充分的需求输入（功能/数据/性能/质量）

---

## 错误处理约定

**ERROR 级别**（终止执行）：
- 提示词文件不存在或为空
- 核心功能域无法识别
- 需求维度未覆盖或描述不明确
- 质量门控验证失败（3轮后仍未通过）
- 目标目录已存在（编号冲突）

**WARN 级别**（记录警告但继续）：
- 代码库分析脚本执行失败
- 索引文件缺失
- 目标URL不可访问
- 需求与项目禁止项冲突（提供替代方案）

---

## 规范引用

**项目规范**：
- `CodexFeatured/Common/BackendConstitution.yaml` - 技术栈约束与禁止项
- `CodexFeatured/Common/BestPractise.yaml` - 最佳实践指南
- `CodexFeatured/Common/CodebaseStructure.yaml` - 项目结构文档
- `Kobe/index.yaml` - 项目能力索引

**工作流版本**：2.0 | **最后更新**：2025-10-11

---

*基于 SpecKit 工程实践 v2.1.1 - 融合用户业务理解与工程级执行控制*

