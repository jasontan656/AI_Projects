---
description: 测试场景精化工作流 - 基于用户反馈优化测试场景文档
version: 2.0
language: zh-CN
upstream: TestScenarioAnalysis_V2
downstream: TestPlanGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/get-test-context.ps1 -Json
---

# TestScenarioSpecify - 测试场景精化工作流

## 工作流概述

**目标**：读取已生成的测试场景文档，根据用户反馈优化和调整测试场景。

**适用场景**：
- 用户阅读测试场景文档后，发现需要补充场景
- 需要调整某些场景的验收标准
- 需要调整场景优先级
- 需要修改随机化策略
- 需要增加新的测试维度

**核心原则**：
- 保留原场景文档的优秀部分
- 精准识别用户输入对文档的影响范围
- 明确标注修改内容
- 支持多次迭代优化

**输入**：
- 现有测试场景文档 `Kobe/SimulationTest/{MODULE_NAME}_testscenarios.md`
- 用户补充需求（通过参数传入）

**输出**：更新后的测试场景文档（覆盖原文件，建议先Git备份）

---

## 参数定义

```yaml
OUTPUT_DIR: "D:/AI_Projects/Kobe/SimulationTest"
MODULE_NAME: "{{RUNTIME_RESOLVE}}"
SCENARIO_FILE: "${OUTPUT_DIR}/${MODULE_NAME}_testscenarios.md"
USER_INPUT: "$ARGUMENTS"
```

---

## 执行流程

### 步骤1：加载现有测试场景文档

**动作**：
1. **运行上下文脚本**（如果配置）：
   ```
   从仓库根目录运行 `{SCRIPT}` 并解析JSON获取：
   - MODULE_NAME: 模块名称
   - SCENARIO_FILE: 测试场景文档路径
   ```
   → 如果脚本执行失败或未配置：继续手动扫描

2. **自动定位测试场景文档**：
   - 扫描 `${OUTPUT_DIR}` 下所有 *_testscenarios.md 文件
   - 按修改时间倒序，选择最新的
   → 如果找到多个候选：
     * 检查文件修改时间，选择最新的
     * WARN "找到多个测试场景文档，选择最新的: {选择的路径}"
   → 如果未找到：
     * ERROR "未找到测试场景文档。请先运行 TestScenarioAnalysis_V2"

3. **验证用户输入**：
   - 验证 `$ARGUMENTS` 不为空
     → 如果为空：ERROR "必须提供补充需求。使用 -a 参数传入，例如：codex -p TestScenarioSpecify_V2.md -a '增加场景：...'"

4. **读取完整测试场景文档**：
   - 读取 `${SCENARIO_FILE}` 完整内容
   - 提取标识信息：MODULE_NAME、COUNT_3D、INTENT_TITLE_2_4
   - 解析文档结构：
     * 第1节：项目理解
     * 第2节：测试场景设计（7个维度）
     * 第3节：场景统计
     * 第4节：执行顺序建议
     * 第5节：随机化总策略
     * 第6节：验收标准总览

5. **备份提示**：
   ```
   INFO "找到测试场景文档: ${SCENARIO_FILE}"
   INFO "建议操作：在修改前使用 Git 备份当前版本"
   INFO "备份命令：git add ${SCENARIO_FILE} && git commit -m 'backup: 测试场景精化前备份'"
   ```

6. **更新进度**：现有测试场景文档加载完成

**输出**：
- SCENARIO_FILE 路径
- MODULE_NAME
- 测试场景文档完整内容
- 文档各章节的解析结果

---

### 步骤2：分析用户输入的影响范围

**动作**：
1. **解析用户输入**：
   - 读取 `$ARGUMENTS` 的内容
   - 识别用户输入的类型：
     * **增加场景**：关键词"增加场景"、"新增测试"、"补充场景"
     * **调整优先级**：关键词"优先级"、"P0"、"P1"、"改为"
     * **修改验收标准**：关键词"验收标准"、"成功标准"、"响应时间"
     * **调整随机化**：关键词"随机化"、"随机策略"、"数据量"
     * **增加测试维度**：关键词"新增维度"、"补充维度"
     * **删除场景**：关键词"删除场景"、"移除"
     * **补充细节**：其他描述性内容

2. **分析影响范围**：

   **影响范围映射表**：
   
   | 用户输入类型 | 影响的文档章节 | 影响程度 |
   |------------|--------------|---------|
   | 增加场景 | 第2节（对应维度）、第3节（统计）、第4节（执行顺序） | 中 |
   | 调整优先级 | 第2节（场景描述）、第3节（统计）、第4节（执行顺序） | 低 |
   | 修改验收标准 | 第2节（场景描述）、第6节（验收标准总览） | 低 |
   | 调整随机化 | 第2节（场景描述）、第5节（随机化总策略） | 中 |
   | 增加测试维度 | 第2节（新增维度）、第3节（统计）、第5节、第6节 | 高 |
   | 删除场景 | 第2节（对应维度）、第3节（统计）、第4节（执行顺序） | 中 |
   | 补充细节 | 第2节（场景描述） | 低 |

   **示例分析**：
   
   ```
   用户输入："增加场景：测试100并发用户，验证系统在高并发下的稳定性"
   
   分析结果：
   - 类型：增加场景
   - 影响章节：
     * 第2.3节：并发与性能维度（新增Scenario-3.3）
     * 第3节：场景统计（并发与性能场景数+1）
     * 第4节：执行顺序（P1场景+1，约增加20分钟）
   - 影响程度：中
   - 修改策略：在第2.3节末尾追加新场景，更新统计和执行顺序
   ```

3. **确定修改策略**：
   - **高影响**（影响≥3个章节）：重写受影响章节
   - **中影响**（影响2个章节）：更新受影响章节的部分内容
   - **低影响**（影响1个章节）：补充具体章节的内容

4. **生成修改计划**：
   ```markdown
   ## 修改计划
   
   **用户输入**：{$ARGUMENTS}
   
   **影响分析**：
   - 输入类型：{类型}
   - 影响程度：{高/中/低}
   - 受影响章节：{列表}
   
   **修改策略**：{策略}
   
   **预计修改内容**：
   - 第X节：{修改描述}
   - 第Y节：{修改描述}
   ...
   ```

5. **更新进度**：影响范围分析完成

**输出**：
- 用户输入类型
- 影响范围（受影响的章节列表）
- 影响程度（高/中/低）
- 修改策略
- 修改计划

---

### 步骤3：更新测试场景文档

**动作**：
1. **按修改计划更新文档**：

   **更新原则**：
   - 保留不受影响的章节内容
   - 在修改处添加标记 `<!-- MODIFIED: {修改原因} -->`
   - 更新统计数据
   - 更新文档头部的"最后修改时间"
   - 在文档末尾添加"修改历史"章节（如果不存在则创建）

2. **按场景更新**：

   **场景1：增加新场景**
   
   ```markdown
   ### 2.3 维度3：并发与性能
   
   #### Scenario-3.1：10并发用户
   ...（原有内容）
   
   #### Scenario-3.2：持续压力测试
   ...（原有内容）
   
   <!-- MODIFIED: 增加100并发场景 -->
   
   #### Scenario-3.3：100并发用户
   - **优先级**：P1
   - **描述**：100个用户同时发起导入请求，验证系统在高并发下的稳定性
   - **输入**：
     * 100个并发请求
     * 每个请求导入不同的文件（100条消息）
   - **操作**：
     1. 使用threading启动100个线程
     2. 每个线程调用导入API
     3. 记录每个请求的响应时间和成功/失败状态
   - **预期输出**：
     * 成功率 ≥ 95%
     * 平均响应时间 < 2分钟
     * P95响应时间 < 5分钟
     * 无数据库死锁
     * 无内存溢出
   - **验收标准**：
     * 成功率 ≥ 95%
     * 无500错误
     * 服务不崩溃
   - **随机化策略**：
     * 请求间隔随机（0-2秒）
     * 文件大小随机（50-150条消息）
     * 随机失败注入（5%概率）
   - **依赖关系**：依赖Scenario-3.1（先测10并发再测100并发）
   ```

   **场景2：调整优先级**
   
   ```markdown
   <!-- MODIFIED: 调整优先级从P1到P0 -->
   
   #### Scenario-1.3：空文件导入
   - **优先级**：P0（原为P1）
   - **描述**：导入空的HTML文件（0条消息）
   ...
   ```

   **场景3：修改验收标准**
   
   ```markdown
   <!-- MODIFIED: 放宽响应时间要求 -->
   
   #### Scenario-1.2：大文件导入
   - **优先级**：P1
   - **描述**：导入包含10000条消息的Telegram HTML文件
   ...
   - **验收标准**：
     * 响应时间 < 10分钟（原为5分钟）
     * 内存占用 < 500MB
     * 无OOM错误
   ```

   **场景4：调整随机化策略**
   
   ```markdown
   <!-- MODIFIED: 增强随机化策略 -->
   
   #### Scenario-2.1：特殊字符处理
   ...
   - **随机化策略**：
     * 随机组合不同类型的特殊字符
     * 表情符号随机选择（从100个常用表情中随机）
     * 代码块语言随机（Python/JavaScript/SQL/Bash）
     * HTML标签随机组合（嵌套深度1-5层）
   ```

3. **更新第3节：场景统计**：
   ```markdown
   ## 3. 场景统计
   
   <!-- MODIFIED: 更新并发与性能维度统计 -->
   
   | 维度 | 场景数量 | P0场景 | P1场景 | P2场景 | P3场景 |
   |------|---------|--------|--------|--------|--------|
   | 功能覆盖 | 15 | 5 | 7 | 2 | 1 |
   | 数据多样性 | 10 | 2 | 6 | 2 | 0 |
   | 并发与性能 | 9 | 1 | 6 | 2 | 0 |  <!-- +1 -->
   | 配置分支 | 12 | 4 | 6 | 2 | 0 |
   | 异常恢复 | 10 | 2 | 6 | 2 | 0 |
   | 依赖服务 | 8 | 2 | 4 | 2 | 0 |
   | 真实场景 | 5 | 3 | 2 | 0 | 0 |
   | **总计** | **69** | **19** | **37** | **12** | **1** |  <!-- 总数+1 -->
   ```

4. **更新第4节：执行顺序建议**：
   ```markdown
   ## 4. 执行顺序建议
   
   <!-- MODIFIED: 更新P1场景时间 -->
   
   1. **第一轮**：执行所有P0场景（19个）
      - 验证核心功能可用
      - 时间：约2小时
   
   2. **第二轮**：执行所有P1场景（37个）  <!-- 原为36个 -->
      - 验证重要功能和边界情况
      - 时间：约4.5小时  <!-- 原为4小时 -->
   ```

5. **添加修改历史**（文档末尾）：
   ```markdown
   ---
   
   ## 修改历史
   
   ### 修改记录 #1
   
   **修改时间**：{YYYY-MM-DD HH:mm:ss}
   
   **修改原因**：{$ARGUMENTS}
   
   **影响章节**：
   - 第2.3节：并发与性能
   - 第3节：场景统计
   - 第4节：执行顺序建议
   
   **修改摘要**：
   - 增加场景Scenario-3.3：100并发用户测试
   - 更新并发与性能维度场景数：8 → 9
   - 更新P1场景总数：36 → 37
   - 更新执行时间：4小时 → 4.5小时
   
   **修改者**：AI（TestScenarioSpecify 工作流）
   
   ---
   
   *（如果后续有更多修改，追加到此处）*
   ```

6. **更新文档头部标识**：
   ```markdown
   标识信息：MODULE_NAME={MODULE_NAME}；COUNT_3D={COUNT_3D}；INTENT_TITLE_2_4={INTENT_TITLE_2_4}；生成时间={原始生成时间}；最后修改时间={YYYY-MM-DD HH:mm:ss}
   ```

7. **写入文件**：
   ```
   写入文件：${SCENARIO_FILE}
   编码：UTF-8（无BOM）
   覆盖原文件
   ```

8. **更新进度**：测试场景文档更新完成

**输出**：更新后的测试场景文档

---

## 进度跟踪

**阶段状态**：
- [ ] 步骤1：现有测试场景文档加载完成
- [ ] 步骤2：影响范围分析完成
- [ ] 步骤3：测试场景文档更新完成

---

## 验收标准

**输入要求**：
- [ ] 用户必须通过 `-a` 参数提供补充需求
- [ ] 补充需求描述清晰、具体

**输出文件要求**：
- [ ] 输出路径符合 `${SCENARIO_FILE}`（覆盖原文件）
- [ ] 文件编码为 UTF-8（无BOM）

**文档结构要求**：
- [ ] 保留原有章节结构
- [ ] 受影响的章节包含 `<!-- MODIFIED: ... -->` 标记
- [ ] 包含"修改历史"章节
- [ ] 文档头部更新了"最后修改时间"

**内容质量要求**：
- [ ] 统计数据正确（场景数量、优先级分布）
- [ ] 执行时间估算合理
- [ ] 新增场景包含所有必需字段（描述、输入、操作、预期输出、验收标准、随机化策略、依赖关系）

---

## 错误处理

**ERROR 级别**（终止执行）：
- 用户未提供补充需求（$ARGUMENTS 为空）
- 未找到现有测试场景文档

**WARN 级别**（记录警告但继续）：
- 修改历史章节不存在（自动创建）

---

## 规范引用

**测试规范**：
- `CodexFeatured/Common/SimulationTestingConstitution.yaml` - 测试专用宪法

**上游工作流**：
- `TestScenarioAnalysis_V2` - 测试场景分析

**下游工作流**：
- `TestPlanGeneration_V2` - 测试计划生成

**工作流版本**：2.0 | **最后更新**：2025-10-11

---

## 使用示例

### 示例1：增加新场景

```bash
# 用户输入
codex -p .codex/prompts/TestScenarioSpecify_V2.md -a "增加场景：测试100并发用户，验证系统在高并发下的稳定性"

# AI执行
# - 识别为"增加场景"类型
# - 影响章节：第2.3节、第3节、第4节
# - 在第2.3节末尾添加Scenario-3.3
# - 更新统计和执行时间
# - 添加修改标记和修改历史

# 输出
# 更新后的测试场景文档，包含新场景
```

### 示例2：调整优先级

```bash
# 用户输入
codex -p .codex/prompts/TestScenarioSpecify_V2.md -a "将Scenario-1.3（空文件导入）的优先级从P1调整为P0，这是核心边界测试"

# AI执行
# - 识别为"调整优先级"类型
# - 影响章节：第2.1节、第3节、第4节
# - 更新场景优先级
# - 更新统计（P0+1, P1-1）
# - 更新执行顺序

# 输出
# 更新后的测试场景文档，优先级已调整
```

### 示例3：修改验收标准

```bash
# 用户输入
codex -p .codex/prompts/TestScenarioSpecify_V2.md -a "放宽Scenario-1.2（大文件导入）的响应时间要求，从5分钟改为10分钟"

# AI执行
# - 识别为"修改验收标准"类型
# - 影响章节：第2.1节、第6节
# - 更新验收标准
# - 更新验收标准总览

# 输出
# 更新后的测试场景文档，验收标准已放宽
```

### 示例4：调整随机化策略

```bash
# 用户输入
codex -p .codex/prompts/TestScenarioSpecify_V2.md -a "增强Scenario-2.1（特殊字符处理）的随机化策略，增加表情符号、代码块语言、HTML标签的随机组合"

# AI执行
# - 识别为"调整随机化"类型
# - 影响章节：第2.2节、第5节
# - 更新场景的随机化策略
# - 更新随机化总策略（如果需要）

# 输出
# 更新后的测试场景文档，随机化策略已增强
```

---

## 与其他工作流的关系

```
TestScenarioAnalysis_V2 (生成测试场景文档)
    ↓
    ↓ (用户阅读后发现需要调整)
    ↓
TestScenarioSpecify_V2 (精化测试场景文档) ← 可多次迭代
    ↓
    ↓ (场景确定后)
    ↓
TestPlanGeneration_V2 (生成测试计划)
    ↓
TestTechDecisions_V2 (生成技术决策)
    ↓
TestExecuteAndDebug_V2 (执行测试与调试)
```

**关键特点**：
- **可选步骤**：如果测试场景文档已满足要求，可直接进入Step 3
- **可迭代**：可以多次运行此步骤，逐步完善场景文档
- **有影响**：修改测试场景后，下游文档（测试计划、技术决策）需要重新生成

---

*基于用户反馈的测试场景迭代优化工作流*

