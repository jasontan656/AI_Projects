---
description: 测试场景分析工作流 - 基于开发文档深度分析测试场景
version: 2.0
language: zh-CN
upstream: DevPiplineExcute_V2
downstream: TestPlanGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/get-test-context.ps1 -Json
---

# TestScenarioAnalysis - 测试场景分析工作流

## 工作流概述

**目标**：深度理解项目开发意图和实现，发散性思考测试场景，生成测试场景文档。

**核心原则**：
- 基于需求文档理解开发目的
- 浏览实际代码理解实现细节
- 发散性思考：从多个维度设计测试场景
- 考虑随机性和多样性（大文件、小文件、并发、边界等）
- 测试场景要完整（不是简单脚本，是完整组件）

**输入**：
- 需求文档 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DemandDescription.md`
- 开发计划 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DevPlan.md`（如果存在）
- 技术决策 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/Tech_Decisions.md`（如果存在）
- 任务清单 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/Tasks.md`（如果存在）
- 项目代码（Kobe/项目代码）

**输出**：测试场景文档 `Kobe/SimulationTest/{功能模块名}_testscenarios.md`

---

## 参数定义

```yaml
OUTPUT_DIR: "D:/AI_Projects/Kobe/SimulationTest"
DEV_PLANS_DIR: "D:/AI_Projects/CodexFeatured/DevPlans"
COUNT_3D: "{{RUNTIME_RESOLVE}}"
INTENT_TITLE_2_4: "{{RUNTIME_RESOLVE}}"
MODULE_NAME: "{{RUNTIME_RESOLVE}}"
SOURCE_DIR: "${DEV_PLANS_DIR}/${COUNT_3D}_${INTENT_TITLE_2_4}"
DEMAND_PATH: "${SOURCE_DIR}/DemandDescription.md"
PLAN_PATH: "${SOURCE_DIR}/DevPlan.md"
TECH_PATH: "${SOURCE_DIR}/Tech_Decisions.md"
TASKS_PATH: "${SOURCE_DIR}/Tasks.md"
OUTPUT_FILE: "${OUTPUT_DIR}/${MODULE_NAME}_testscenarios.md"
```

---

## 执行流程

### 步骤1：加载开发文档与项目规范

**动作**：
1. **定位最新开发项目**：
   - 扫描 `${DEV_PLANS_DIR}` 下所有项目目录
   - 查找包含 DemandDescription.md 的目录
   - 按编号倒序，选择最新的
   - 提取 COUNT_3D 和 INTENT_TITLE_2_4
   → 如果未找到：ERROR "未找到开发项目"

2. **读取所有开发文档**：
   - 读取 `${DEMAND_PATH}` 完整内容（必需）
   - 读取 `${PLAN_PATH}` 完整内容（如果存在）
   - 读取 `${TECH_PATH}` 完整内容（如果存在）
   - 读取 `${TASKS_PATH}` 完整内容（如果存在）

3. **加载测试专用宪法**（关键！）：
   - 读取 `CodexFeatured/Common/SimulationTestingConstitution.yaml` 并严格遵守
   - 读取 `CodexFeatured/Common/BackendConstitution.yaml` 了解项目约束
   - 读取 `CodexFeatured/Common/BestPractise.yaml` 了解最佳实践

4. **更新进度**：开发文档和规范加载完成

**输出**：
- 需求文档内容
- 开发计划内容
- 技术决策内容
- 任务清单内容
- 测试宪法内容

---

### 步骤2：代码库深度扫描与理解

**动作**：
1. **运行代码结构脚本**：
   ```bash
   python CodexFeatured/Scripts/CodebaseStructure.py
   ```
   - 生成最新的代码结构文档

2. **读取项目结构**：
   - 读取 `CodexFeatured/Common/CodebaseStructure.yaml`
   - 读取 `Kobe/index.yaml`
   - 按 relation 自顶向下遍历所有 index.yaml

3. **定位目标模块**：
   - 从需求文档提取模块名称（如 TelegramCuration）
   - 确定模块路径（如 Kobe/TelegramCuration/）
   - 设置 MODULE_NAME

4. **扫描目标模块代码**：
   - 读取模块下所有关键文件：
     * `__init__.py` - 模块导出
     * `models.py` - 数据模型
     * `services.py` - 核心服务逻辑
     * `routers.py` - API路由（如果有）
     * `tasks.py` - Celery任务（如果有）
     * `config.py` - 配置
     * `README.md` - 模块说明

5. **理解实现细节**（关键！）：
   - API端点列表：哪些HTTP端点？请求/响应格式？
   - CLI命令：哪些命令行入口？
   - 异步任务：哪些Celery任务？
   - 依赖服务：依赖哪些服务（Redis/MongoDB/RabbitMQ/Chromadb）？
   - 数据流：输入→处理→输出的完整流程
   - 配置项：有哪些可配置项？默认值？

6. **识别关键组件**：
   - 哪些是核心功能？
   - 哪些是辅助功能？
   - 哪些是配置相关？
   - 哪些是错误处理？

7. **更新进度**：代码库扫描完成，实现细节已理解

**输出**：
- 模块名称（MODULE_NAME）
- 模块路径
- API端点清单
- CLI命令清单
- Celery任务清单
- 依赖服务清单
- 数据流图
- 配置项清单

---

### 步骤3：发散性思考测试场景（关键步骤！）

**动作**：
1. **从多个维度思考测试场景**：

   **维度1：功能覆盖**
   - 从需求文档第2节"核心功能需求"提取所有功能点
   - 每个功能点至少1个测试场景
   - 示例：
     ```
     功能：导入Telegram HTML并解析
     测试场景：
     - 场景1.1：正常导入（包含10-20条消息的HTML）
     - 场景1.2：大文件导入（包含10000条消息的HTML）
     - 场景1.3：空文件导入（0条消息）
     - 场景1.4：格式错误的HTML（缺少必需字段）
     - 场景1.5：特殊字符处理（表情、代码块、链接）
     ```

   **维度2：数据多样性**
   - 小数据量（10-20条）
   - 中等数据量（100-500条）
   - 大数据量（10000+条）
   - 边界情况：空数据、单条数据、极大数据
   - 数据类型：文本、图片、视频、文件
   - 特殊字符：表情、换行、HTML标签、SQL注入字符

   **维度3：并发与性能**
   - 单用户串行请求
   - 10并发用户
   - 100并发用户
   - 持续压力测试（1小时持续请求）
   - 峰值突发（短时间内大量请求）

   **维度4：配置分支**
   - Redis开启 vs Redis关闭
   - MongoDB本地 vs MongoDB远程
   - 大模型API正常 vs 大模型API超时/失败
   - 缓存开启 vs 缓存关闭
   - Debug模式 vs Production模式

   **维度5：异常与错误恢复**
   - 网络超时
   - 服务重启（Celery worker重启）
   - 数据库连接中断
   - 磁盘空间不足
   - 内存不足
   - 中途取消任务

   **维度6：依赖服务状态**
   - Redis正常 vs Redis宕机
   - MongoDB正常 vs MongoDB宕机
   - RabbitMQ正常 vs RabbitMQ宕机
   - Chromadb正常 vs Chromadb宕机
   - 大模型API正常 vs API限流/超时

   **维度7：真实使用场景**（基于需求文档第1节"业务背景"）
   - 用户的典型使用流程
   - 用户的极端使用场景
   - 用户可能犯的错误
   - 示例：
     ```
     业务背景：用户想从Telegram聊天记录中整理知识
     真实场景：
     - 场景7.1：用户导入个人聊天记录（小群，100条消息）
     - 场景7.2：用户导入工作群聊天记录（大群，10000条消息）
     - 场景7.3：用户导入多个群的记录（批量导入）
     - 场景7.4：用户中途取消导入（因为太慢）
     - 场景7.5：用户重复导入（幂等性测试）
     ```

2. **场景优先级排序**：
   - P0：核心功能，必须测试
   - P1：重要功能，应该测试
   - P2：辅助功能，可选测试
   - P3：边缘情况，时间允许再测试

3. **场景依赖关系**：
   - 哪些场景依赖其他场景的结果？
   - 哪些场景可以并行执行？
   - 哪些场景必须串行执行？

4. **随机性设计**（关键！）：
   - 为每个场景设计随机化策略：
     * 随机数据量（10-100随机）
     * 随机顺序（消息顺序随机）
     * 随机延迟（模拟网络延迟0-5秒）
     * 随机失败（10%概率模拟API失败）
   - 目的：模拟真实用户的不可预测行为

5. **验收标准定义**：
   - 每个场景明确的成功标准
   - 可量化的指标（响应时间、错误率、成功率）
   - 可观测的结果（日志、数据库记录、文件输出）

6. **更新进度**：测试场景分析完成

**输出**：
- 7个维度的测试场景清单（50-100个场景）
- 每个场景包含：
  * 场景编号（如 Scenario-1.1）
  * 场景名称（如"正常导入小文件"）
  * 场景描述（输入、操作、预期输出）
  * 优先级（P0/P1/P2/P3）
  * 依赖关系（依赖哪些场景）
  * 随机化策略（如何引入随机性）
  * 验收标准（什么情况算成功）

---

### 步骤4：生成测试场景文档

**动作**：
1. **生成文档结构**：

   ```markdown
   # 测试场景文档：{模块名称}

   标识信息：MODULE_NAME={MODULE_NAME}；COUNT_3D={COUNT_3D}；INTENT_TITLE_2_4={INTENT_TITLE_2_4}；生成时间={YYYY-MM-DD HH:mm:ss}

   **参考文档**：
   - 需求文档：{DEMAND_PATH}
   - 开发计划：{PLAN_PATH}
   - 技术决策：{TECH_PATH}
   - 任务清单：{TASKS_PATH}

   **输出路径**：{OUTPUT_FILE}

   ---

   ## 1. 项目理解

   ### 1.1 开发目的
   {从需求文档第1节提取：为什么开发这个功能？}

   ### 1.2 核心功能
   {从需求文档第2节提取：实现了哪些功能？}

   ### 1.3 技术架构
   {从开发计划第2节提取：模块划分、依赖关系}

   ### 1.4 实现细节
   - API端点：{列表}
   - CLI命令：{列表}
   - Celery任务：{列表}
   - 依赖服务：{列表}
   - 数据流：输入 → 处理 → 输出

   ---

   ## 2. 测试场景设计

   ### 2.1 维度1：功能覆盖

   #### Scenario-1.1：正常导入小文件
   - **优先级**：P0
   - **描述**：导入包含10-20条消息的Telegram HTML文件
   - **输入**：
     * HTML文件：test_data/telegram_small.html（18条消息）
     * API调用：POST /api/telegram-curation/ingest/start
     * payload：{"sourceDir": "test_data/", "workspaceDir": "outputs/"}
   - **操作**：
     1. 调用导入API
     2. 轮询任务状态（每2秒查询一次，最多30次）
     3. 等待任务完成
   - **预期输出**：
     * 任务状态：completed
     * 解析消息数：18条
     * 数据库记录：MongoDB chat_messages 集合包含18条记录
     * 输出文件：outputs/parsed_messages.json 包含18个对象
   - **验收标准**：
     * 响应时间 < 30秒
     * 所有消息字段完整（message_id, sender, text, created_at）
     * 无解析错误日志
   - **随机化策略**：
     * 消息内容随机生成
     * 消息顺序随机打乱
   - **依赖关系**：无

   #### Scenario-1.2：大文件导入
   - **优先级**：P1
   - **描述**：导入包含10000条消息的Telegram HTML文件
   - **输入**：
     * HTML文件：test_data/telegram_large.html（10000条消息）
     * API调用：POST /api/telegram-curation/ingest/start
   - **操作**：同Scenario-1.1
   - **预期输出**：
     * 任务状态：completed
     * 解析消息数：10000条
     * 处理时间：< 5分钟
   - **验收标准**：
     * 响应时间 < 5分钟
     * 内存占用 < 500MB
     * 无OOM错误
   - **随机化策略**：
     * 消息数量：9000-11000随机
     * 消息长度：10-500字符随机
   - **依赖关系**：依赖Scenario-1.1（先测小文件再测大文件）

   #### Scenario-1.3：空文件导入
   - **优先级**：P1
   - **描述**：导入空的HTML文件（0条消息）
   - **输入**：
     * HTML文件：test_data/telegram_empty.html（0条消息）
   - **操作**：同Scenario-1.1
   - **预期输出**：
     * 任务状态：completed
     * 解析消息数：0条
     * 输出：空数组或提示"无消息"
   - **验收标准**：
     * 不抛出异常
     * 返回友好提示
   - **随机化策略**：无
   - **依赖关系**：无

   ---

   ### 2.2 维度2：数据多样性

   #### Scenario-2.1：特殊字符处理
   - **优先级**：P1
   - **描述**：导入包含特殊字符的消息（表情、代码块、HTML标签）
   - **输入**：
     * 消息1："Hello 😀"（表情）
     * 消息2："`python\nprint('hello')`"（代码块）
     * 消息3："<script>alert('xss')</script>"（HTML标签）
   - **预期输出**：
     * 表情正确解码
     * 代码块格式保留
     * HTML标签被转义或去除
   - **验收标准**：
     * 无XSS漏洞
     * 特殊字符不丢失
   - **随机化策略**：
     * 随机组合不同类型的特殊字符
   - **依赖关系**：无

   ---

   ### 2.3 维度3：并发与性能

   #### Scenario-3.1：10并发用户
   - **优先级**：P1
   - **描述**：10个用户同时发起导入请求
   - **输入**：
     * 10个并发请求
     * 每个请求导入不同的文件（100条消息）
   - **操作**：
     1. 使用threading启动10个线程
     2. 每个线程调用导入API
     3. 记录每个请求的响应时间
   - **预期输出**：
     * 所有请求都成功
     * 平均响应时间 < 1分钟
     * P95响应时间 < 2分钟
   - **验收标准**：
     * 无500错误
     * 无数据库死锁
     * 无任务丢失
   - **随机化策略**：
     * 请求间隔随机（0-5秒）
     * 文件大小随机（50-150条消息）
   - **依赖关系**：依赖Scenario-1.1

   ---

   ### 2.4 维度4：配置分支

   #### Scenario-4.1：Redis开启
   - **优先级**：P0
   - **描述**：Redis正常运行时的测试
   - **前置条件**：
     * Redis服务运行在localhost:6379
     * config.py中REDIS_URL配置正确
   - **输入**：同Scenario-1.1
   - **预期输出**：
     * 缓存命中率 > 0（第二次请求命中缓存）
     * 响应时间比无缓存快50%+
   - **验收标准**：
     * redis-cli可查询到缓存键
   - **依赖关系**：无

   #### Scenario-4.2：Redis关闭
   - **优先级**：P1
   - **描述**：Redis未启动时的降级测试
   - **前置条件**：
     * Redis服务未启动
   - **输入**：同Scenario-1.1
   - **预期输出**：
     * 功能正常（降级到无缓存模式）
     * 响应时间稍慢但可接受
     * 日志记录"Redis连接失败，降级到无缓存模式"
   - **验收标准**：
     * 不抛出异常
     * 功能完整
   - **依赖关系**：无

   ---

   ### 2.5 维度5：异常与错误恢复

   #### Scenario-5.1：网络超时
   - **优先级**：P1
   - **描述**：大模型API超时时的处理
   - **输入**：
     * 模拟大模型API超时（设置timeout=1秒）
   - **预期输出**：
     * 自动重试3次
     * 最终失败后标记为"需人工复核"
     * 不阻塞整个流程
   - **验收标准**：
     * 重试次数正确
     * 错误日志清晰
   - **依赖关系**：无

   #### Scenario-5.2：Celery worker重启
   - **优先级**：P1
   - **描述**：任务执行过程中worker重启
   - **输入**：
     * 启动一个长任务（处理1000条消息）
     * 5秒后重启Celery worker
   - **预期输出**：
     * 任务自动重新入队
     * 任务最终完成（或标记失败）
     * 不丢失数据
   - **验收标准**：
     * 任务状态正确
     * 无重复处理
   - **依赖关系**：无

   ---

   ### 2.6 维度6：依赖服务状态

   #### Scenario-6.1：MongoDB宕机恢复
   - **优先级**：P2
   - **描述**：MongoDB宕机后恢复的测试
   - **操作**：
     1. 停止MongoDB服务
     2. 尝试导入（应该失败）
     3. 启动MongoDB服务
     4. 重试导入（应该成功）
   - **预期输出**：
     * 第一次失败，错误信息明确
     * 第二次成功，数据完整
   - **验收标准**：
     * 错误处理优雅
     * 恢复后正常
   - **依赖关系**：无

   ---

   ### 2.7 维度7：真实使用场景

   #### Scenario-7.1：用户典型流程
   - **优先级**：P0
   - **描述**：模拟用户完整使用流程
   - **操作**：
     1. 用户导出Telegram聊天记录（HTML）
     2. 用户上传文件到服务
     3. 服务解析消息
     4. 服务生成知识切片
     5. 服务生成QA对
     6. 用户查询QA
   - **预期输出**：
     * 每个步骤都成功
     * 最终用户能查询到QA
   - **验收标准**：
     * 端到端无错误
     * 结果符合预期
   - **随机化策略**：
     * 文件大小随机
     * 查询关键词随机
   - **依赖关系**：依赖Scenario-1.1, Scenario-2.1

   ---

   ## 3. 场景统计

   | 维度 | 场景数量 | P0场景 | P1场景 | P2场景 | P3场景 |
   |------|---------|--------|--------|--------|--------|
   | 功能覆盖 | 15 | 5 | 7 | 2 | 1 |
   | 数据多样性 | 10 | 2 | 6 | 2 | 0 |
   | 并发与性能 | 8 | 1 | 5 | 2 | 0 |
   | 配置分支 | 12 | 4 | 6 | 2 | 0 |
   | 异常恢复 | 10 | 2 | 6 | 2 | 0 |
   | 依赖服务 | 8 | 2 | 4 | 2 | 0 |
   | 真实场景 | 5 | 3 | 2 | 0 | 0 |
   | **总计** | **68** | **19** | **36** | **12** | **1** |

   ---

   ## 4. 执行顺序建议

   1. **第一轮**：执行所有P0场景（19个）
      - 验证核心功能可用
      - 时间：约2小时

   2. **第二轮**：执行所有P1场景（36个）
      - 验证重要功能和边界情况
      - 时间：约4小时

   3. **第三轮**（可选）：执行P2场景（12个）
      - 验证辅助功能
      - 时间：约2小时

   4. **第四轮**（可选）：执行P3场景（1个）
      - 验证边缘情况
      - 时间：约30分钟

   ---

   ## 5. 随机化总策略

   为了模拟真实用户的不可预测行为，引入以下随机化机制：

   ### 5.1 数据随机化
   - 消息数量：在指定范围内随机（如10-20条）
   - 消息内容：从预定义词库随机生成
   - 消息顺序：随机打乱
   - 消息长度：10-500字符随机

   ### 5.2 时间随机化
   - 请求间隔：0-5秒随机
   - 消息时间戳：过去30天内随机

   ### 5.3 配置随机化
   - 每次测试随机选择一种配置组合
   - 如：Redis开/关、MongoDB本地/远程等

   ### 5.4 失败注入
   - 10%概率模拟API超时
   - 5%概率模拟网络中断
   - 1%概率模拟服务重启

   ---

   ## 6. 验收标准总览

   ### 6.1 功能性标准
   - 所有P0场景100%通过
   - 所有P1场景≥95%通过
   - 无阻塞性Bug

   ### 6.2 性能标准
   - API响应时间P95 < 需求文档指标
   - 并发支持数 ≥ 需求文档指标
   - 内存占用 < 500MB（正常负载）

   ### 6.3 稳定性标准
   - 连续运行1小时无崩溃
   - 错误率 < 1%
   - 恢复时间 < 10秒

   ### 6.4 可观测性标准
   - 所有关键操作有日志
   - 错误信息清晰明确
   - 可通过日志追踪问题

   ---

   **工作流版本**：2.0 | **生成时间**：{YYYY-MM-DD HH:mm:ss}
   ```

2. **写入文件**：
   ```
   写入文件：${OUTPUT_FILE}
   编码：UTF-8（无BOM）
   ```

3. **更新进度**：测试场景文档生成完成

**输出文件**：`${OUTPUT_FILE}`

---

## 进度跟踪

**阶段状态**：
- [ ] 步骤1：开发文档和规范加载完成
- [ ] 步骤2：代码库扫描完成，实现细节已理解
- [ ] 步骤3：测试场景分析完成（7个维度）
- [ ] 步骤4：测试场景文档生成完成

---

## 验收标准

**输出文件要求**：
- [ ] 输出路径符合 `${OUTPUT_FILE}`
- [ ] 文件编码为 UTF-8（无BOM）
- [ ] 文件大小 > 20KB（确保详细）

**测试场景要求**：
- [ ] 包含7个维度的场景分析
- [ ] 场景总数 ≥ 50个
- [ ] P0场景 ≥ 15个
- [ ] 每个场景包含：描述、输入、操作、预期输出、验收标准、随机化策略、依赖关系
- [ ] 场景覆盖所有核心功能（从需求文档提取）

**随机化要求**：
- [ ] 每个场景都有随机化策略（即使是"无"）
- [ ] 随机化策略具体可执行（不是"适当随机化"）

**理解深度要求**：
- [ ] 深度理解代码实现（不仅读需求文档）
- [ ] 识别所有API端点/CLI命令/Celery任务
- [ ] 识别所有依赖服务
- [ ] 理解完整数据流

---

## 错误处理

**ERROR 级别**（终止执行）：
- 未找到需求文档
- 未找到目标模块代码
- 测试宪法不存在

**WARN 级别**（记录警告但继续）：
- 开发计划不存在（使用需求文档补充）
- 技术决策不存在（从代码推断）

---

## 规范引用

**测试规范**：
- `CodexFeatured/Common/SimulationTestingConstitution.yaml` - 测试专用宪法（必读）
- `CodexFeatured/Common/BackendConstitution.yaml` - 项目技术栈约束
- `CodexFeatured/Common/BestPractise.yaml` - 最佳实践

**开发文档**：
- `DemandDescription.md` - 需求文档（理解开发目的）
- `DevPlan.md` - 开发计划（理解架构）
- `Tech_Decisions.md` - 技术决策（理解技术细节）
- `Tasks.md` - 任务清单（理解实现步骤）

**项目结构**：
- `CodexFeatured/Common/CodebaseStructure.yaml` - 代码结构
- `Kobe/index.yaml` - 模块索引

**工作流版本**：2.0 | **最后更新**：2025-10-11

---

*基于开发文档深度分析的测试场景设计 - 完整组件，不是简单脚本*

