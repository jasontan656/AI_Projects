---
description: 工程化"需求文档精化"工作流 - 基于用户反馈优化和调整需求文档
version: 2.1
language: zh-CN
upstream: DevFuncDemandsWrite_V2
downstream: DevPlanGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/get-demand-context.ps1 -Json
---

# DevFuncDemandsSpecify - 需求文档精化工作流

## 工作流概述

**目标**：读取已生成的需求文档，根据用户的补充需求或调整意见，重新分析、调研、更新需求文档。

**适用场景**：
- 用户阅读AI生成的需求文档后，发现需要补充的内容
- 需求方向发生变化（如从"一次性工具"改为"可复用服务"）
- 需要增加新的功能点或约束条件
- 需要调整性能指标或交付物

**核心原则**：
- 保留原需求文档的优秀部分
- 精准识别用户输入对文档的影响范围
- 重新调研受影响的部分
- 明确标注修改内容
- 支持多次迭代优化

**输入**：
- 现有需求文档 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DemandDescription.md`
- 用户补充需求（通过参数传入）

**输出**：更新后的需求文档（覆盖原文件，建议先Git备份）

---

## 参数定义

```yaml
OUTPUT_DIR_PATH: "D:/AI_Projects/CodexFeatured/DevPlans"
COUNT_3D: "{{RUNTIME_RESOLVE}}"          # 从现有文档解析
INTENT_TITLE_2_4: "{{RUNTIME_RESOLVE}}"  # 从现有文档解析
DEMAND_FILENAME: "DemandDescription.md"
TARGET_DIR: "${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}"
DEMAND_PATH: "${TARGET_DIR}/${DEMAND_FILENAME}"
USER_INPUT: "$ARGUMENTS"                  # 用户通过命令行参数传入的补充需求
```

---

## 执行流程（DevFuncDemandsSpecify 工作流范围）

**用户输入处理**：

用户**必须**通过命令参数传入补充需求或调整意见。格式示例：

```bash
# 示例1：增加新功能
codex -p DevFuncDemandsSpecify_V2.md -a "增加功能：支持多用户导出各自的Telegram聊天记录"

# 示例2：调整需求方向
codex -p DevFuncDemandsSpecify_V2.md -a "将当前的一次性工具改为可复用的服务，支持其他用户使用"

# 示例3：增加约束
codex -p DevFuncDemandsSpecify_V2.md -a "增加约束：必须支持增量更新，避免重复处理已归档的消息"

# 示例4：调整性能指标
codex -p DevFuncDemandsSpecify_V2.md -a "性能要求：单次处理至少支持10万条消息"
```

用户输入：

$ARGUMENTS

→ 如果 $ARGUMENTS 为空：
  * ERROR "必须提供补充需求或调整意见。使用 -a 参数传入，例如：codex -p DevFuncDemandsSpecify_V2.md -a '增加功能：...'"

---

### 步骤1：加载现有需求文档

**动作**：
1. **运行上下文获取脚本**（如果配置）：
   ```
   从仓库根目录运行 `{SCRIPT}` 并解析JSON获取：
   - TARGET_DIR: 目标目录
   - COUNT_3D: 需求编号
   - INTENT_TITLE_2_4: 意图标识
   - DEMAND_PATH: 现有需求文档路径
   ```
   → 如果脚本执行失败或未配置：继续手动扫描

2. **自动定位最新需求文档**：
   - 扫描 `${OUTPUT_DIR_PATH}` 下所有子目录
   - 查找包含 DemandDescription.md 的目录
   - 按目录编号倒序排列（最大编号优先）
   - 选择最近修改的目录作为目标
   → 如果找到多个候选：
     * 检查文件修改时间，选择最新的
     * WARN "找到多个候选目录，选择最新的: {选择的路径}"
   → 如果未找到：
     * ERROR "未找到需求文档。请先运行 DevFuncDemandsWrite_V2 生成需求文档"

3. **验证需求文档存在**：
   - 验证 `${DEMAND_PATH}` 存在
     → 如果不存在：ERROR "需求文档不存在，请先运行 DevFuncDemandsWrite_V2"

4. **读取完整需求文档**：
   - 读取 `${DEMAND_PATH}` 完整内容
   - 从文档头部提取标识信息：COUNT_3D、INTENT_TITLE_2_4、生成时间
   - 解析文档结构，识别所有章节：
     * 第1节：业务背景与目标
     * 第2节：核心功能需求
     * 第3节：数据需求
     * 第4节：技术约束
     * 第5节：性能与质量指标
     * 第6节：用户体验要求
     * 第7节：安全性与合规性
     * 第8节：可扩展性与维护性
     * 第9节：依赖关系与集成
     * 第10节：交付物清单
     * 第11节：交付与验收标准
     * 第12节：风险与应对策略

5. **备份提示**：
   ```
   INFO "找到需求文档: ${DEMAND_PATH}"
   INFO "建议操作：在修改前使用 Git 备份当前版本"
   INFO "备份命令：git add ${DEMAND_PATH} && git commit -m 'backup: 需求文档精化前备份'"
   ```

6. **更新进度**：现有需求文档加载完成

**输出**：
- TARGET_DIR、DEMAND_PATH
- COUNT_3D、INTENT_TITLE_2_4
- 现有需求文档完整内容
- 文档各章节的解析结果

---

### 步骤2：分析用户输入的影响范围

**动作**：
1. **解析用户输入**：
   - 读取 `$ARGUMENTS` 的内容
   - 识别用户输入的类型：
     * **增加功能**：关键词"增加功能"、"新增"、"加入"
     * **调整方向**：关键词"改为"、"调整为"、"变更为"
     * **增加约束**：关键词"约束"、"限制"、"必须"、"禁止"
     * **修改指标**：关键词"性能"、"响应时间"、"吞吐量"、"并发"
     * **补充细节**：其他描述性内容

2. **分析影响范围**（关键步骤！）：
   
   **影响范围映射表**：
   
   | 用户输入类型 | 影响的文档章节 | 影响程度 | 是否需要重新调研 |
   |------------|--------------|---------|----------------|
   | 增加功能 | 第2节（核心功能）、第3节（数据需求）、第10节（交付物）、第11节（验收标准） | 高 | 是 |
   | 调整方向 | 第1节（业务背景）、第2节（核心功能）、第6节（用户体验）、第8节（可扩展性） | 极高 | 是 |
   | 增加约束 | 第4节（技术约束）、第7节（安全合规）、第12节（风险） | 中 | 可能 |
   | 修改指标 | 第5节（性能质量）、第11节（验收标准） | 中 | 否 |
   | 补充细节 | 根据内容判断 | 低-中 | 可能 |

   **示例分析**：
   
   ```
   用户输入："将当前的一次性工具改为可复用的服务，支持其他用户使用"
   
   分析结果：
   - 类型：调整方向
   - 影响章节：
     * 第1节：业务背景需要更新（从"个人工具"变为"多用户服务"）
     * 第2节：核心功能需要增加（用户管理、权限、多租户）
     * 第3节：数据需求需要更新（增加用户数据、会话隔离）
     * 第4节：技术约束需要更新（需要身份认证、数据库）
     * 第5节：性能指标需要更新（支持并发用户）
     * 第6节：用户体验需要重新设计（Web界面或API）
     * 第7节：安全性需要加强（用户隔离、数据加密）
     * 第8节：可扩展性需要考虑（水平扩展）
     * 第10节：交付物需要更新（增加用户模块）
     * 第11节：验收标准需要更新（多用户测试）
   - 影响程度：极高（需要大幅重写）
   - 需要重新调研：是
   ```

3. **确定修改策略**：
   - **极高影响**（影响≥8个章节）：
     * 策略：重新生成整个文档（保留部分基础调研）
     * 提示：建议用户重新运行 DevFuncDemandsWrite_V2
   - **高影响**（影响5-7个章节）：
     * 策略：重写受影响章节，保留其他章节
   - **中影响**（影响2-4个章节）：
     * 策略：更新受影响章节的部分内容
   - **低影响**（影响1个章节）：
     * 策略：补充具体章节的内容

4. **生成修改计划**：
   ```markdown
   ## 修改计划
   
   **用户输入**：{$ARGUMENTS}
   
   **影响分析**：
   - 输入类型：{类型}
   - 影响程度：{极高/高/中/低}
   - 受影响章节：{列表}
   
   **修改策略**：{策略}
   
   **预计修改内容**：
   - 第X节：{修改描述}
   - 第Y节：{修改描述}
   ...
   ```

5. **向用户确认**（如果影响程度为"极高"）：
   ```
   WARN "检测到重大需求变更，影响程度：极高"
   WARN "受影响章节：{列表}"
   WARN "建议：如需大幅调整需求，建议重新运行 DevFuncDemandsWrite_V2"
   INFO "继续执行将大幅重写现有文档，是否继续？（本工作流将自动继续，请人工审核后决定是否保留）"
   ```

6. **更新进度**：影响范围分析完成

**输出**：
- 用户输入类型
- 影响范围（受影响的章节列表）
- 影响程度（极高/高/中/低）
- 修改策略
- 修改计划

---

### 步骤3：重新调研与信息补充

**动作**：
1. **判断是否需要调研**：
   → 如果影响程度为"极高"或"高"，或用户输入类型为"增加功能"、"调整方向"：
     * 需要重新调研
   → 否则：
     * 跳过调研，直接进入步骤4

2. **加载项目规范**（与 DevFuncDemandsWrite_V2 一致）：
   - 读取 `CodexFeatured/Common/BackendConstitution.yaml`
   - 读取 `CodexFeatured/Common/CodeCommentStandard.yaml`
   - 读取 `CodexFeatured/Common/BestPractise.yaml`
   - 读取 `CodexFeatured/Common/CodebaseStructure.yaml`（如果存在）

3. **调研新增或变更的需求**：
   
   **调研内容**（基于影响范围）：
   
   - **如果影响"功能需求"**：
     * 调研：新功能的技术可行性
     * 调研：新功能与现有功能的关系
     * 调研：新功能需要的依赖或技术栈
   
   - **如果影响"数据需求"**：
     * 调研：新数据的来源、格式、量级
     * 调研：数据存储方案（内存/数据库/文件）
     * 调研：数据隐私与安全要求
   
   - **如果影响"技术约束"**：
     * 调研：新约束与项目规范的兼容性
     * 调研：新约束对现有技术栈的影响
   
   - **如果影响"用户体验"**（如从CLI改为Web）：
     * 调研：用户交互方式（Web/API/CLI）
     * 调研：前端技术栈（如果需要）
     * 调研：用户认证与会话管理

4. **联网调研**（如果需要）：
   
   **调研策略**（与 DevFuncDemandsWrite_V2 一致）：
   - 对新增的技术关键词进行调研
   - 对变更的功能方向进行最佳实践调研
   - 对新增的约束条件进行可行性调研
   
   **调研输出示例**：
   ```markdown
   ## 调研结果
   
   ### 多用户支持的技术方案
   - 用户认证：使用 FastAPI + JWT
   - 数据隔离：基于 user_id 的行级隔离
   - 会话管理：Redis存储会话
   
   ### 参考项目
   - Project A：类似的多租户架构（GitHub链接）
   - Project B：用户认证最佳实践（文档链接）
   ```

5. **更新进度**：调研与信息补充完成

**输出**：
- 项目规范文档内容
- 调研结果（针对新增或变更的需求）

---

### 步骤4：更新需求文档

**动作**：
1. **按修改计划更新文档**：

   **更新原则**：
   - 保留不受影响的章节内容
   - 重写受影响的章节
   - 在修改处添加标记 `<!-- MODIFIED: {修改原因} -->`
   - 更新文档头部的"最后修改时间"
   - 在文档末尾添加"修改历史"章节

2. **按章节更新**（根据影响范围）：

   **示例：更新第2节（核心功能需求）**
   ```markdown
   ## 2. 核心功能需求
   
   <!-- MODIFIED: 调整为多用户服务架构 -->
   
   ### 2.1 用户管理功能（新增）
   
   **功能描述**：支持用户注册、登录、权限管理
   
   **输入**：
   - 用户注册：邮箱、密码、用户名
   - 用户登录：邮箱、密码
   
   **输出**：
   - JWT Token（有效期24小时）
   - 用户信息（user_id、权限级别）
   
   **业务规则**：
   - 邮箱唯一性验证
   - 密码强度要求（至少8位，包含字母和数字）
   - 支持密码找回（邮件验证）
   
   ---
   
   ### 2.2 聊天记录导入功能（修改）
   
   <!-- MODIFIED: 增加用户隔离，每个用户只能访问自己的数据 -->
   
   **功能描述**：支持用户导入自己的Telegram聊天记录
   
   **输入**：
   - 用户上传的JSON格式聊天记录文件
   - 用户认证Token（确保数据隔离）
   
   **输出**：
   - 解析后的消息列表（关联到当前用户）
   - 导入状态报告
   
   **业务规则**：
   - 数据隔离：每个用户只能查看自己导入的数据
   - 增量导入：自动识别已存在的消息，避免重复
   - 文件大小限制：单次最大100MB
   
   ...（其他功能点）
   ```

   **示例：更新第5节（性能与质量指标）**
   ```markdown
   ## 5. 性能与质量指标
   
   <!-- MODIFIED: 增加并发用户支持指标 -->
   
   ### 5.1 响应时间
   - API接口响应时间 < 200ms（P95）
   - 大模型调用响应时间 < 3s（P95）
   - 文件上传响应时间 < 5s（100MB文件）
   
   ### 5.2 吞吐量
   - 支持并发用户数：≥ 100（新增）
   - 支持同时处理的聊天记录导入任务：≥ 10（新增）
   - 单用户单次处理消息数：≥ 10万条
   
   ### 5.3 可用性
   - 服务可用性：≥ 99%（新增）
   - 支持水平扩展（通过负载均衡）（新增）
   
   ...
   ```

3. **更新第10节（交付物清单）**：
   - 根据新增或变更的功能，更新交付物清单
   - 示例：如果增加了"多用户支持"，需要增加：
     * 用户认证模块（`Kobe/UserAuth/`）
     * 用户数据库迁移脚本（`Kobe/migrations/`）
     * API文档（`docs/api.md`）

4. **更新第11节（验收标准）**：
   - 根据新增或变更的功能，更新验收标准
   - 示例：增加"多用户测试"验收标准：
     ```
     - [ ] 用户A上传的数据，用户B无法访问
     - [ ] 支持100个并发用户同时访问
     - [ ] 用户注册、登录、密码找回功能正常
     ```

5. **添加修改历史**（文档末尾）：
   ```markdown
   ---
   
   ## 修改历史
   
   ### 修改记录 #1
   
   **修改时间**：{YYYY-MM-DD HH:mm:ss}
   
   **修改原因**：{$ARGUMENTS}
   
   **影响章节**：
   - 第1节：业务背景与目标
   - 第2节：核心功能需求
   - 第5节：性能与质量指标
   - 第10节：交付物清单
   - 第11节：交付与验收标准
   
   **修改摘要**：
   - 将一次性工具调整为多用户可复用服务
   - 增加用户认证与权限管理功能
   - 增加数据隔离与安全要求
   - 更新性能指标，支持并发用户
   - 更新交付物清单和验收标准
   
   **修改者**：AI（DevFuncDemandsSpecify 工作流）
   
   ---
   
   *（如果后续有更多修改，追加到此处）*
   ```

6. **更新文档头部标识**：
   ```markdown
   标识信息：INTENT_TITLE_2_4={INTENT_TITLE_2_4}；COUNT_3D={COUNT_3D}；生成时间={原始生成时间}；最后修改时间={YYYY-MM-DD HH:mm:ss}
   ```

7. **写入文件**：
   ```
   写入文件：${DEMAND_PATH}
   编码：UTF-8（无BOM）
   覆盖原文件
   ```

8. **更新进度**：需求文档更新完成

**输出**：更新后的需求文档文件

---

### 步骤5：一致性与质量验证（质量门控）

*门控：必须在输出文档前通过。最多尝试3轮修正。*

**动作**：
1. **执行验证检查**：

   **检查1：文档结构完整性**
   - 验证所有12个必需章节存在
   - 验证章节编号连续（1-12）
   - 验证"修改历史"章节存在
   → 如果缺少：FAIL "文档结构不完整，缺少章节: {章节}"

   **检查2：修改标记一致性**
   - 验证所有受影响的章节都有 `<!-- MODIFIED: ... -->` 标记
   - 验证修改标记的原因描述清晰
   → 如果缺少：FAIL "受影响章节缺少修改标记: {章节}"

   **检查3：业务闭环检查**（与 DevFuncDemandsWrite_V2 一致）
   - 验证输入→处理→输出逻辑完整
   - 验证新增功能的数据流清晰
   → 如果不完整：FAIL "业务闭环不完整: {详情}"

   **检查4：交付物与功能一致性**
   - 验证新增功能有对应的交付物
   - 验证新增功能有对应的验收标准
   → 如果不一致：FAIL "功能 {功能名} 缺少对应的交付物或验收标准"

   **检查5：技术约束合规性**
   - 验证新增的技术栈符合 BackendConstitution.yaml
   - 验证新增的依赖不在禁止清单
   → 如果不合规：FAIL "技术约束违规: {详情}"

   **检查6：修改历史完整性**
   - 验证"修改历史"章节包含：修改时间、原因、影响章节、摘要
   - 验证修改摘要准确反映实际修改内容
   → 如果不完整：FAIL "修改历史不完整"

2. **处理验证结果**：
   → 如果所有检查通过：
     * 更新进度：质量门控通过
     * 继续步骤6
   → 如果任何检查失败：
     * 修正内容
     * 重新写入
     * 重新验证（最多3轮）
     * 如果3轮后仍失败：ERROR "质量门控验证失败: {详情}"

3. **更新进度**：质量门控验证通过

---

### 步骤6：完成与报告

**动作**：
1. **输出执行摘要**：
   ```markdown
   ## 需求文档精化完成
   
   **文档路径**：{DEMAND_PATH}
   **编号**：{COUNT_3D}
   **意图标识**：{INTENT_TITLE_2_4}
   **修改时间**：{YYYY-MM-DD HH:mm:ss}
   
   **用户输入**：{$ARGUMENTS}
   
   **修改统计**：
   - 影响程度：{极高/高/中/低}
   - 受影响章节数：{数量}
   - 新增功能点：{数量}
   - 新增交付物：{数量}
   - 新增验收标准：{数量}
   
   **受影响章节**：
   - 第1节：业务背景与目标
   - 第2节：核心功能需求
   - 第5节：性能与质量指标
   - 第10节：交付物清单
   - 第11节：交付与验收标准
   
   **修改摘要**：
   {简要描述主要修改内容}
   
   **建议操作**：
   1. 仔细审核修改后的需求文档
   2. 如果满意，使用 Git 提交：
      git add ${DEMAND_PATH}
      git commit -m "需求精化: {简短描述}"
   3. 继续下一步工作流：
      codex -p .codex/prompts/DevPlanGeneration_V2.md
   
   **注意事项**：
   - 如果已存在开发计划（DevPlan.md）、技术决策（Tech_Decisions.md）或任务清单（Tasks.md），
     需要重新运行相应的工作流以保持一致性
   - 建议删除旧的计划/决策/任务文档，重新生成
   ```

2. **检查下游文档冲突**：
   - 检查是否存在 `${TARGET_DIR}/DevPlan.md`
     → 如果存在：WARN "检测到已存在的开发计划，建议删除并重新生成"
   - 检查是否存在 `${TARGET_DIR}/Tech_Decisions.md`
     → 如果存在：WARN "检测到已存在的技术决策，建议删除并重新生成"
   - 检查是否存在 `${TARGET_DIR}/Tasks.md`
     → 如果存在：WARN "检测到已存在的任务清单，建议删除并重新生成"

3. **更新进度**：工作流执行完成

---

## 进度跟踪

*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 步骤1：现有需求文档加载完成
- [ ] 步骤2：影响范围分析完成
- [ ] 步骤3：调研与信息补充完成
- [ ] 步骤4：需求文档更新完成
- [ ] 步骤5：质量门控验证通过
- [ ] 步骤6：工作流执行完成

**质量门控状态**：
- [ ] 文档结构完整性检查：通过
- [ ] 修改标记一致性检查：通过
- [ ] 业务闭环检查：通过
- [ ] 交付物与功能一致性检查：通过
- [ ] 技术约束合规性检查：通过
- [ ] 修改历史完整性检查：通过

---

## 验收标准（Acceptance Criteria）

**输入要求**：
- [ ] 用户必须通过 `-a` 参数提供补充需求或调整意见
- [ ] 补充需求描述清晰、具体

**输出文件要求**：
- [ ] 输出路径符合 `${DEMAND_PATH}`（覆盖原文件）
- [ ] 文件编码为 UTF-8（无BOM）
- [ ] 文件大小 > 10KB（确保内容完整）

**文档结构要求**：
- [ ] 包含所有12个必需章节
- [ ] 包含"修改历史"章节
- [ ] 受影响的章节包含 `<!-- MODIFIED: ... -->` 标记
- [ ] 文档头部更新了"最后修改时间"

**内容质量要求**：
- [ ] 业务闭环完整（输入→处理→输出）
- [ ] 新增功能有对应的交付物
- [ ] 新增功能有对应的验收标准
- [ ] 技术约束符合项目规范

**修改历史要求**：
- [ ] 包含修改时间、原因、影响章节、修改摘要
- [ ] 修改摘要准确反映实际修改内容

---

## 错误处理约定

**ERROR 级别**（终止执行）：
- 用户未提供补充需求（$ARGUMENTS 为空）
- 未找到现有需求文档
- 质量门控验证失败（3轮后仍未通过）
- 技术约束违规

**WARN 级别**（记录警告但继续）：
- 影响程度为"极高"（建议重新生成）
- 检测到已存在的下游文档（需要重新生成）

---

## 规范引用

**项目规范**：
- `CodexFeatured/Common/BackendConstitution.yaml` - 技术栈约束与禁止项
- `CodexFeatured/Common/CodeCommentStandard.yaml` - 注释风格要求
- `CodexFeatured/Common/BestPractise.yaml` - 最佳实践指南

**上游工作流**：
- `DevFuncDemandsWrite_V2` - 需求文档生成

**下游工作流**：
- `DevPlanGeneration_V2` - 开发计划生成
- `TechDecisionsGeneration_V2` - 技术决策生成
- `DevPipelineGeneration_V2` - 任务清单生成

**工作流版本**：2.1 | **最后更新**：2025-10-11

---

## 使用示例

### 示例1：增加新功能

```bash
# 用户输入
codex -p .codex/prompts/DevFuncDemandsSpecify_V2.md -a "增加功能：支持定时自动导入Telegram消息，每天凌晨2点自动运行"

# AI执行
# - 识别为"增加功能"类型
# - 影响章节：第2节（功能）、第4节（技术约束）、第10节（交付物）
# - 调研：定时任务技术方案（Celery Beat、APScheduler）
# - 更新相关章节
# - 添加修改标记和修改历史

# 输出
# 更新后的 DemandDescription.md，包含新功能描述
```

### 示例2：调整需求方向

```bash
# 用户输入
codex -p .codex/prompts/DevFuncDemandsSpecify_V2.md -a "将当前的个人工具改为企业级服务，支持团队协作和权限管理"

# AI执行
# - 识别为"调整方向"类型，影响程度：极高
# - WARN：建议重新生成需求文档
# - 影响章节：几乎所有章节（1-12）
# - 调研：企业级服务的架构、权限模型、团队协作最佳实践
# - 大幅重写受影响章节
# - 添加修改标记和详细修改历史

# 输出
# 更新后的 DemandDescription.md，大幅调整为企业级服务需求
# 建议：删除旧的计划/决策/任务文档，重新生成
```

### 示例3：增加约束

```bash
# 用户输入
codex -p .codex/prompts/DevFuncDemandsSpecify_V2.md -a "增加约束：必须支持离线运行，不依赖外部API"

# AI执行
# - 识别为"增加约束"类型
# - 影响章节：第4节（技术约束）、第9节（依赖关系）
# - 调研：大模型本地部署方案（如果原需求依赖外部大模型）
# - 更新技术约束，调整依赖关系
# - 添加修改标记和修改历史

# 输出
# 更新后的 DemandDescription.md，包含离线运行约束
```

### 示例4：修改性能指标

```bash
# 用户输入
codex -p .codex/prompts/DevFuncDemandsSpecify_V2.md -a "性能要求：单次处理至少支持100万条消息，响应时间<10秒"

# AI执行
# - 识别为"修改指标"类型
# - 影响章节：第5节（性能指标）、第11节（验收标准）
# - 无需调研（直接更新指标）
# - 更新性能指标和验收标准
# - 添加修改标记和修改历史

# 输出
# 更新后的 DemandDescription.md，包含新的性能指标
```

---

## 与其他工作流的关系

```
DevFuncDemandsWrite_V2 (生成初始需求文档)
    ↓
    ↓ (用户阅读后发现需要调整)
    ↓
DevFuncDemandsSpecify_V2 (精化需求文档) ← 可多次迭代
    ↓
    ↓ (需求确定后)
    ↓
DevPlanGeneration_V2 (生成开发计划)
    ↓
TechDecisionsGeneration_V2 (生成技术决策)
    ↓
DevPipelineGeneration_V2 (生成任务清单)
    ↓
DevPiplineExcute_V2 (执行开发)
```

**关键特点**：
- **可选步骤**：如果初始需求文档已满足要求，可直接跳到 DevPlanGeneration_V2
- **可迭代**：可以多次运行 DevFuncDemandsSpecify_V2 进行增量优化
- **有影响**：修改需求文档后，下游文档（计划、决策、任务）需要重新生成

---

*基于 SpecKit 工程实践 v2.1.1 - 需求文档迭代优化工作流*

