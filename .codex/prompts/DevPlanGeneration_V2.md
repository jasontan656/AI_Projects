---
description: 工程化"开发计划文档生成"工作流 - 从需求文档到架构设计与模块规划
version: 2.0
language: zh-CN
upstream: DevFuncDemandsWrite_V2
downstream: TechDecisionsGeneration_V2
scripts:
  ps: CodexFeatured/Scripts/get-plan-context.ps1 -Json
---

# DevPlanGeneration - 开发计划文档生成工作流

## 工作流概述

**目标**：读取需求文档，进行架构设计、模块划分、目录结构规划，生成完整的开发计划文档。

**核心原则**：
- 聚焦架构层面的"怎么组织"
- 模块职责清晰、边界明确
- 目录结构符合项目规范
- 为下游技术决策提供架构基础

**输入**：需求文档 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DemandDescription.md`  
**输出**：开发计划 `CodexFeatured/DevPlans/{COUNT_3D}_{INTENT_TITLE_2_4}/DevPlan.md`

---

## 参数定义

```yaml
OUTPUT_DIR_PATH: "D:/AI_Projects/CodexFeatured/DevPlans"
COUNT_3D: "{{RUNTIME_RESOLVE}}"          # 从需求文档解析
INTENT_TITLE_2_4: "{{RUNTIME_RESOLVE}}"  # 从需求文档解析
DEMAND_FILENAME: "DemandDescription.md"
PLAN_FILENAME: "DevPlan.md"
DEMAND_PATH: "${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}/${DEMAND_FILENAME}"
PLAN_PATH: "${OUTPUT_DIR_PATH}/${COUNT_3D}_${INTENT_TITLE_2_4}/${PLAN_FILENAME}"
```

---

## 执行流程（DevPlanGeneration 工作流范围）

**用户输入处理**：

用户可通过命令参数传入需求文档路径或其他配置。在继续执行前，你**必须**考虑用户输入（若不为空）。

用户输入：

$ARGUMENTS

---

### 步骤1：定位并加载需求文档

**动作**：
1. **运行上下文获取脚本**（如果配置）：
   ```
   从仓库根目录运行 `{SCRIPT}` 并解析JSON获取：
   - TARGET_DEMAND_PATH: 目标需求文档路径
   - TARGET_DIR: 需求文档所在目录
   - EXISTING_PLAN: 是否已存在 DevPlan.md
   ```
   → 如果脚本执行失败或未配置：继续手动扫描

2. **自动扫描目标需求文档**：
   - 扫描 `${OUTPUT_DIR_PATH}` 下所有子目录
   - 查找包含 `${DEMAND_FILENAME}` 的目录
   - 按目录编号倒序排列（最大编号优先）
   - 选择最近修改的 DemandDescription.md 作为目标
   → 如果找到多个候选：
     * 检查文件修改时间，选择最新的
     * WARN "找到多个需求文档，选择最新的: {选择的路径}"
   → 如果未找到任何需求文档：
     * ERROR "未找到需求文档，请先运行 DevFuncDemandsWrite 生成需求文档"

3. **读取并解析需求文档**：
   - 读取目标文件完整内容
   - 从文档头部提取标识信息：COUNT_3D、INTENT_TITLE_2_4
   → 如果标识信息缺失：ERROR "需求文档标识信息缺失"
   - 设置输出路径：
     * `TARGET_DIR = dirname(目标文件路径)`
     * `PLAN_PATH = "${TARGET_DIR}/${PLAN_FILENAME}"`

4. **解析需求文档核心内容**：
   - 提取"项目背景与目标"：
     * 核心目标
     * 业务价值
     * 非技术目标
   - 提取"功能需求描述"：
     * 所有功能点列表
     * 功能范围与边界
   - 提取"数据需求描述"：
     * 数据来源与目标
     * 数据类型与结构
     * 数据量级
   - 提取"性能与质量要求"：
     * 性能指标（响应时间、吞吐量、并发）
     * 质量指标（准确性、可用性）
   - 提取"项目约束说明"：
     * 技术栈约束
     * 路径约束
     * 环境变量约束

5. **验证开发计划文件状态**：
   → 如果 `${PLAN_PATH}` 已存在：
     * WARN "开发计划已存在: {PLAN_PATH}，将覆盖现有文件"

6. **更新进度**：需求文档加载完成

**输出**：
- TARGET_DIR、DEMAND_PATH、PLAN_PATH
- COUNT_3D、INTENT_TITLE_2_4
- 需求文档核心内容（已解析）

---

### 步骤2：加载项目上下文与规范

**动作**：
1. **运行代码库结构分析脚本**：
   ```python
   运行 CodexFeatured/Scripts/CodebaseStructure.py
   ```
   → 如果脚本执行失败：WARN "代码库分析脚本执行失败"

2. **读取项目结构与能力图谱**：
   - 读取 `CodexFeatured/Common/CodebaseStructure.yaml`
   - 读取 `Kobe/index.yaml` 作为入口
   - 遍历所有 `index.yaml` 文件，构建：
     * 已实现功能模块清单（路径、功能、接口）
     * 现有目录结构（backend、frontend、shared）
     * 命名规范（文件、模块、变量）

3. **加载开发规范**：
   - 读取 `CodexFeatured/Common/BackendConstitution.yaml`：
     * 技术栈定义（Python版本、框架、存储）
     * 强制要求（mandates）
     * 禁止项（prohibitions）
     * 目录组织规范
   - 读取 `CodexFeatured/Common/BestPractise.yaml`：
     * 架构模式推荐
     * 模块划分原则

4. **构建可复用模块清单**：
   - 现有功能模块：RichLogger、TaskQueue等
   - 基础设施组件：Redis、MongoDB、RabbitMQ配置
   - 工具函数与中间件

5. **更新进度**：项目上下文加载完成

**输出**：
- 现有模块清单
- 现有目录结构
- 项目规范约束
- 命名规范

---

### 步骤3：架构设计（质量门控点）

*门控：架构设计必须符合项目规范，模块职责必须清晰*

**动作**：
1. **识别功能域与模块**：
   - 从需求文档的功能点中识别功能域：
     * 用户认证域
     * 数据处理域
     * 外部集成域
     * 报表生成域
     * 等等
   - 对每个功能域，识别需要的模块：
     * 数据模型（models）
     * 业务逻辑（services）
     * API接口（routers/controllers）
     * 工具函数（utils）
     * 后台任务（tasks，如果需要Celery）

2. **模块职责定义**：
   - 对每个模块，定义：
     * **模块名称**：符合命名规范
     * **职责描述**（50-100字）：明确该模块负责什么
     * **输入/输出**：接收什么参数，返回什么结果
     * **依赖关系**：依赖哪些其他模块
     * **是否复用现有模块**：如果是，标注复用的模块路径

3. **架构分层设计**：
   - **数据层**：
     * 数据模型定义（Pydantic models）
     * 数据访问接口（如果需要数据库）
   - **业务层**：
     * 核心业务逻辑
     * 数据转换与验证
   - **接口层**：
     * HTTP API（FastAPI routers）
     * 或命令行接口（CLI）
   - **任务层**（如果需要）：
     * Celery 异步任务
     * 任务编排（chain/group/chord）

4. **数据流设计**：
   - 绘制数据流图（文字描述）：
     ```
     输入数据 → 数据验证 → 业务处理 → 数据转换 → 输出结果
              ↓
              日志记录
              ↓
              性能监控
     ```
   - 标注关键数据转换点
   - 标注缓存策略（如果适用）

5. **验证架构合理性**：
   - 验证模块职责单一且清晰
     → 如果模块职责模糊：FAIL "模块 {模块名} 职责不清晰"
   - 验证依赖关系无循环依赖
     → 如果存在循环依赖：FAIL "存在循环依赖: {依赖链}"
   - 验证架构符合项目约束
     → 如果违反约束：FAIL "架构设计违反项目约束: {约束项}"

6. **更新进度**：架构设计完成（门控通过）

**输出**：
- 功能域清单
- 模块清单（含职责、输入/输出、依赖关系）
- 架构分层设计
- 数据流设计

---

### 步骤4：目录结构规划

**动作**：
1. **确定项目类型**：
   - 从需求文档和架构设计推断项目类型：
     * 单体应用（backend only）
     * Web应用（backend + frontend）
     * 命令行工具（CLI + lib）
     * 后台服务（tasks + workers）

2. **规划目录结构**：

   **对于单体应用**：
   ```
   Kobe/
   ├── {功能模块名}/          # 主功能模块
   │   ├── __init__.py
   │   ├── models.py          # 数据模型
   │   ├── services.py        # 业务逻辑
   │   ├── routers.py         # API接口（如果需要）
   │   ├── tasks.py           # Celery任务（如果需要）
   │   └── utils.py           # 工具函数
   ├── SharedUtility/         # 复用现有共享模块
   │   ├── RichLogger/
   │   └── TaskQueue/
   └── TempUtility/           # 临时/一次性功能模块
       └── {功能模块名}/
   ```

   **对于Web应用**：
   ```
   kobe/backend/
   ├── {功能模块名}/
   │   ├── models.py
   │   ├── services.py
   │   ├── routers.py
   │   └── tasks.py
   └── shared/
       └── utils.py

   frontend/
   ├── components/
   │   └── {功能组件}/
   ├── pages/
   │   └── {功能页面}/
   └── services/
       └── api.ts
   ```

3. **文件命名与组织**：
   - 对于每个模块目录，规划文件：
     * **models.py**：Pydantic 数据模型
     * **services.py**：核心业务逻辑
     * **routers.py**：FastAPI 路由（如果需要HTTP API）
     * **tasks.py**：Celery 任务定义（如果需要后台任务）
     * **utils.py**：工具函数
     * **__init__.py**：模块导出
   - 遵循项目命名规范：
     * 文件名：小写下划线（snake_case）
     * 类名：大驼峰（PascalCase）
     * 函数名：小写下划线（snake_case）

4. **配置文件规划**：
   - 如果需要配置文件：
     * `.env` 文件：敏感配置（API Key、数据库连接）
     * `config.py` 或 `settings.py`：应用配置
     * `logging_config.yaml`：日志配置（如果需要）

5. **文档文件规划**：
   - `README.md`：功能模块说明
   - `index.yaml`：模块索引（更新现有索引）
   - 使用文档（如果是库或工具）

6. **验证目录结构**：
   - 验证符合项目规范（从步骤2的规范约束）
     → 如果不符合：FAIL "目录结构不符合项目规范: {详情}"
   - 验证文件命名符合规范
     → 如果不符合：FAIL "文件命名不符合规范: {文件名}"

7. **更新进度**：目录结构规划完成

**输出**：
- 完整的目录结构树（文本形式）
- 文件清单（每个文件的用途）
- 配置文件清单
- 文档文件清单

---

### 步骤5：模块接口设计

**动作**：
1. **定义公共接口**：
   - 对于每个模块，设计对外暴露的接口：
     * **函数签名**：函数名、参数、返回值、异常
     * **类接口**：类名、方法、属性
     * **API端点**（如果需要HTTP API）：路由、请求/响应格式

2. **数据模型定义**：
   - 对于需要的数据模型，定义：
     * **模型名称**：符合命名规范
     * **字段清单**：字段名、类型、是否必需、默认值、验证规则
     * **示例数据**：用于测试和文档
   - 使用 Pydantic v2 语法：
     ```python
     from pydantic import BaseModel, Field
     
     class UserProfile(BaseModel):
         user_id: str = Field(..., description="用户ID")
         email: str = Field(..., description="邮箱")
         created_at: datetime = Field(default_factory=datetime.now)
     ```

3. **API接口规范**（如果需要HTTP API）：
   - 对于每个API端点，定义：
     * **路由**：`POST /api/users/register`
     * **请求格式**：JSON schema
     * **响应格式**：JSON schema
     * **错误码**：400、401、404、500等
     * **认证要求**：是否需要登录态

4. **Celery任务接口**（如果需要后台任务）：
   - 对于每个任务，定义：
     * **任务名称**（slug）：`module.task_name`
     * **参数**：参数名、类型、是否必需
     * **返回值**：成功/失败结果格式
     * **重试策略**：最大重试次数、退避策略
     * **超时设置**：任务超时时间

5. **更新进度**：模块接口设计完成

**输出**：
- 模块接口清单
- 数据模型定义
- API接口规范（如适用）
- Celery任务接口规范（如适用）

---

### 步骤6：生成开发计划文档

**动作**：
1. **生成文档结构**：

   ```markdown
   # 开发计划：{功能名称}

   标识信息：INTENT_TITLE_2_4={INTENT_TITLE_2_4}；COUNT_3D={COUNT_3D}；生成时间={YYYY-MM-DD HH:mm:ss}
   需求文档：{DEMAND_PATH}
   输出路径：{PLAN_PATH}

   ---

   ## 1. 项目概述

   ### 1.1 需求摘要
   [从需求文档提取核心目标，100-200字]

   ### 1.2 开发目标
   [从需求转化为开发目标，明确要实现的功能模块]

   ### 1.3 项目类型
   [单体应用 / Web应用 / CLI工具 / 后台服务]

   ---

   ## 2. 架构设计

   ### 2.1 功能域划分
   [从步骤3提取功能域清单]
   - **功能域1**：{功能域名称}
     - 职责：{职责描述}
     - 包含模块：{模块列表}
   - **功能域2**：...

   ### 2.2 模块清单
   [从步骤3提取模块清单，详细版本]
   
   #### 模块1：{模块名称}
   - **路径**：`Kobe/{功能模块名}/{模块文件}.py`
   - **职责**：{职责描述，50-100字}
   - **输入**：{参数描述}
   - **输出**：{返回值描述}
   - **依赖**：{依赖的其他模块}
   - **是否复用**：是（复用 `{路径}`） / 否（新建）

   [重复其他模块]

   ### 2.3 架构分层
   [从步骤3提取架构分层设计]
   
   ```
   ┌─────────────────────────────────────┐
   │         接口层 (API/CLI)            │
   ├─────────────────────────────────────┤
   │         业务层 (Services)           │
   ├─────────────────────────────────────┤
   │         数据层 (Models)             │
   ├─────────────────────────────────────┤
   │    基础设施层 (Database/Cache)      │
   └─────────────────────────────────────┘
   ```

   **各层职责**：
   - **接口层**：{职责描述}
   - **业务层**：{职责描述}
   - **数据层**：{职责描述}
   - **基础设施层**：{职责描述}

   ### 2.4 数据流设计
   [从步骤3提取数据流设计]
   
   ```
   [输入数据]
      ↓
   [数据验证] ← Pydantic Models
      ↓
   [业务处理] ← Services
      ↓
   [数据转换]
      ↓
   [输出结果]
   
   并行：
   - 日志记录 ← RichLogger
   - 性能监控 ← Metrics
   ```

   ---

   ## 3. 目录结构规划

   ### 3.1 完整目录树
   [从步骤4提取目录结构树]
   
   ```
   Kobe/
   ├── {功能模块名}/
   │   ├── __init__.py           # 模块导出
   │   ├── models.py             # Pydantic 数据模型
   │   ├── services.py           # 核心业务逻辑
   │   ├── routers.py            # FastAPI 路由
   │   ├── tasks.py              # Celery 任务
   │   ├── utils.py              # 工具函数
   │   └── README.md             # 模块说明
   ├── SharedUtility/
   │   ├── RichLogger/           # 复用：统一日志
   │   └── TaskQueue/            # 复用：任务队列
   └── TempUtility/
       └── {功能模块名}/         # 临时/一次性功能
   ```

   ### 3.2 文件职责说明
   [从步骤4提取文件清单]
   
   | 文件路径 | 职责 | 是否新建 |
   |---------|------|---------|
   | `Kobe/{功能模块名}/models.py` | 定义 Pydantic 数据模型 | 是 |
   | `Kobe/{功能模块名}/services.py` | 实现核心业务逻辑 | 是 |
   | ... | ... | ... |

   ### 3.3 配置文件规划
   [从步骤4提取配置文件]
   
   - **Kobe/.env**：敏感配置（API Key、数据库连接）
   - **Kobe/{功能模块名}/config.py**：应用配置

   ---

   ## 4. 模块接口设计

   ### 4.1 数据模型
   [从步骤5提取数据模型定义]
   
   #### UserProfile
   ```python
   from pydantic import BaseModel, Field
   
   class UserProfile(BaseModel):
       """用户画像数据模型"""
       user_id: str = Field(..., description="用户ID")
       email: str = Field(..., description="邮箱")
       created_at: datetime = Field(default_factory=datetime.now)
   ```

   **字段说明**：
   - `user_id`：用户ID，必需，字符串类型
   - `email`：邮箱，必需，字符串类型，需符合邮箱格式
   - `created_at`：创建时间，可选，默认当前时间

   [重复其他模型]

   ### 4.2 公共接口（如果是库/工具）
   [从步骤5提取模块接口]
   
   #### parse_sql_file()
   ```python
   async def parse_sql_file(path: str) -> tuple[list[Table], list[Field]]:
       """
       解析 SQL 文件，提取表和字段信息
       
       参数:
           path: SQL 文件路径
       
       返回:
           (tables, fields): 表列表和字段列表
       
       异常:
           FileNotFoundError: 文件不存在
           ValueError: 文件格式错误
       """
   ```

   [重复其他接口]

   ### 4.3 API接口规范（如果需要HTTP API）
   [从步骤5提取API接口规范]
   
   #### POST /api/users/register
   - **描述**：用户注册
   - **请求格式**：
     ```json
     {
       "email": "user@example.com",
       "password": "password123"
     }
     ```
   - **响应格式**：
     ```json
     {
       "user_id": "uuid",
       "token": "jwt_token"
     }
     ```
   - **错误码**：
     - `400`：参数错误
     - `409`：用户已存在

   [重复其他API]

   ### 4.4 Celery任务接口（如果需要后台任务）
   [从步骤5提取Celery任务接口]
   
   #### process_user_data
   - **任务名称**：`user_module.process_user_data`
   - **参数**：
     - `user_id` (str): 用户ID
     - `data` (dict): 用户数据
   - **返回值**：
     ```json
     {
       "success": true,
       "processed_count": 100
     }
     ```
   - **重试策略**：最大3次，指数退避
   - **超时**：5分钟

   [重复其他任务]

   ---

   ## 5. 模块依赖关系

   ### 5.1 依赖图
   ```
   routers.py
      ↓
   services.py
      ↓
   models.py
   
   并行依赖：
   - RichLogger (日志)
   - TaskQueue (任务队列)
   ```

   ### 5.2 外部依赖
   [列出需要的外部依赖，但不指定具体库和版本，留给下游TechDecisions]
   
   - **SQL解析**：需要SQL解析能力
   - **HTTP客户端**：需要异步HTTP客户端
   - **数据验证**：已有 Pydantic v2

   ---

   ## 6. 复用与新建

   ### 6.1 复用现有模块
   | 模块 | 路径 | 用途 |
   |-----|------|------|
   | RichLogger | Kobe/SharedUtility/RichLogger | 统一日志记录 |
   | TaskQueue | Kobe/SharedUtility/TaskQueue | Celery任务编排 |

   ### 6.2 新建模块
   | 模块 | 路径 | 职责 |
   |-----|------|------|
   | {模块名} | Kobe/{功能模块名}/{文件名}.py | {职责描述} |

   ---

   ## 7. 范围与边界

   ### 7.1 包含功能
   [从需求文档提取]
   - 功能1：{描述}
   - 功能2：{描述}

   ### 7.2 不包含功能
   [从需求文档提取]
   - 不包含1：{描述}
   - 不包含2：{描述}

   ### 7.3 技术边界
   - **做什么**：{描述}
   - **不做什么**：{描述}

   ---

   ## 8. 项目约束遵循

   ### 8.1 技术栈约束
   [从项目规范提取并说明如何遵循]
   - Python 版本：≥ 3.10 ✓
   - 异步I/O：统一使用 async/await ✓
   - 数据验证：使用 Pydantic v2 ✓
   - 日志：统一使用 RichLogger ✓

   ### 8.2 架构约束
   - 模块职责单一 ✓
   - 依赖关系清晰无循环 ✓
   - 符合项目目录规范 ✓

   ---

   ## 9. 下一步工作

   **立即进入**：TechDecisionsGeneration 工作流
   - 定义具体依赖库与版本
   - 定义大模型提示词（如果需要）
   - 定义API对接方案（如果需要）
   - 定义数据字段规范
   - 定义配置文件详细内容

   **后续工作**：
   1. 技术决策文档生成
   2. 任务清单生成（参考需求+计划+技术决策）
   3. 任务执行

   ---

   **工作流版本**：2.0 | **生成时间**：{YYYY-MM-DD HH:mm:ss}
   ```

2. **写入文件**：
   ```
   写入文件：${PLAN_PATH}
   编码：UTF-8（无BOM）
   ```

3. **更新进度**：开发计划文档生成完成

**输出文件**：`${PLAN_PATH}`

---

### 步骤7：规范对齐验证（质量门控）

*门控：必须在输出文档前通过。最多尝试3轮修正。*

**动作**：
1. **读取约束源**：
   - 重新加载 `CodexFeatured/Common/BackendConstitution.yaml`
   - 重新加载需求文档 `${DEMAND_PATH}`

2. **读取生成的开发计划**：
   - 读取 `${PLAN_PATH}` 的完整内容

3. **执行验证检查**：

   **检查1：架构完整性**
   - 验证包含所有必需章节（第1-9节）
   → 如果缺少：FAIL "开发计划缺少必需章节: {章节名}"

   **检查2：模块职责清晰性**
   - 随机抽查5-10个模块：
     * 职责描述是否清晰（50-100字）
     * 输入/输出是否明确
     * 依赖关系是否清晰
   → 如果不清晰：FAIL "模块 {模块名} 职责不清晰"

   **检查3：目录结构符合规范**
   - 验证目录结构符合项目规范（从BackendConstitution.yaml）
   → 如果不符合：FAIL "目录结构不符合项目规范: {详情}"

   **检查4：依赖关系合理性**
   - 验证无循环依赖
   - 验证依赖层次清晰
   → 如果存在问题：FAIL "依赖关系存在问题: {详情}"

   **检查5：接口定义完整性**
   - 验证数据模型定义完整（字段、类型、验证）
   - 验证公共接口签名完整（参数、返回值、异常）
   → 如果不完整：FAIL "接口定义不完整: {详情}"

   **检查6：需求覆盖度**
   - 对比需求文档的功能点与开发计划的模块清单
   - 验证所有功能点都有对应的模块实现
   → 如果缺少覆盖：FAIL "功能点 {功能点} 无对应模块"

   **检查7：文档详细度（关键！针对GPT-5）**
   - 验证模块描述详细度：每个模块职责描述 ≥ 50字
   - 验证数据模型详细度：每个模型包含字段说明
   - 验证接口详细度：每个接口包含参数、返回值、异常说明
   - 验证文档总字数 ≥ 3000字（确保详细）
   → 如果不够详细：FAIL "文档不够详细，总字数: {字数}，要求 ≥ 3000字"

4. **处理验证结果**：
   → 如果所有检查通过：
     * 更新进度：质量门控通过
     * 继续步骤8
   → 如果任何检查失败：
     * 修正开发计划内容
     * 重新写入
     * 重新验证（最多3轮）
     * 如果3轮后仍失败：ERROR "质量门控验证失败: {详情}"

5. **更新进度**：质量门控验证通过

---

### 步骤8：完成与报告

**动作**：
1. **输出执行摘要**：
   ```markdown
   ## 开发计划生成完成

   **输出文件**：{PLAN_PATH}
   **编号**：{COUNT_3D}
   **意图标识**：{INTENT_TITLE_2_4}
   **生成时间**：{YYYY-MM-DD HH:mm:ss}

   **规划统计**：
   - 功能域数量：{数量}
   - 模块数量：{数量}
   - 新建模块：{数量}
   - 复用模块：{数量}
   - 数据模型：{数量}
   - API接口：{数量}（如适用）
   - Celery任务：{数量}（如适用）

   **下一步**：
   请使用 TechDecisionsGeneration 工作流生成技术决策文档，
   定义具体的依赖库、提示词、接口对接方案等技术细节。
   ```

2. **更新进度**：工作流执行完成

---

## 进度跟踪

*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 步骤1：需求文档加载完成
- [ ] 步骤2：项目上下文加载完成
- [ ] 步骤3：架构设计完成（门控通过）
- [ ] 步骤4：目录结构规划完成
- [ ] 步骤5：模块接口设计完成
- [ ] 步骤6：开发计划文档生成完成
- [ ] 步骤7：质量门控验证通过
- [ ] 步骤8：工作流执行完成

**质量门控状态**：
- [ ] 架构设计门控：通过（步骤3）
- [ ] 架构完整性检查：通过（步骤7）
- [ ] 模块职责清晰性检查：通过（步骤7）
- [ ] 目录结构规范检查：通过（步骤7）
- [ ] 依赖关系合理性检查：通过（步骤7）
- [ ] 接口定义完整性检查：通过（步骤7）
- [ ] 需求覆盖度检查：通过（步骤7）
- [ ] 文档详细度检查：通过（步骤7）

---

## 验收标准（Acceptance Criteria）

**输出文件要求**：
- [ ] 输出路径符合 `${PLAN_PATH}`（需求文档同目录）
- [ ] 文件编码为 UTF-8（无BOM）
- [ ] 文件大小 > 20KB（确保详细）
- [ ] 文档总字数 ≥ 3000字

**文档结构要求**：
- [ ] 包含所有9个必需章节
- [ ] 标识信息准确（COUNT_3D、INTENT_TITLE_2_4、生成时间）

**架构设计要求**：
- [ ] 功能域划分清晰
- [ ] 每个模块职责描述 ≥ 50字
- [ ] 所有模块包含输入/输出/依赖说明
- [ ] 架构分层清晰（数据层、业务层、接口层）
- [ ] 数据流设计明确

**目录结构要求**：
- [ ] 目录树完整且符合项目规范
- [ ] 所有文件包含职责说明
- [ ] 符合命名规范（snake_case、PascalCase）

**接口设计要求**：
- [ ] 数据模型包含字段清单、类型、验证规则
- [ ] 公共接口包含参数、返回值、异常说明
- [ ] API接口包含路由、请求/响应格式（如适用）
- [ ] Celery任务包含任务名、参数、重试策略（如适用）

**需求覆盖要求**：
- [ ] 所有功能点都有对应的模块实现
- [ ] 复用现有模块优先于新建

**详细度要求（针对GPT-5）**：
- [ ] 每个模块职责描述详细（≥ 50字）
- [ ] 每个接口定义完整（含参数、返回值、异常、示例）
- [ ] 文档总体详细且充实（≥ 3000字）

---

## 错误处理约定

**ERROR 级别**（终止执行）：
- 需求文档未找到或标识信息缺失
- 架构设计门控失败（循环依赖、职责不清）
- 质量门控验证失败（3轮后仍未通过）
- 文档详细度不足（< 3000字）

**WARN 级别**（记录警告但继续）：
- 代码库分析脚本执行失败
- 开发计划已存在（可选覆盖）

---

## 规范引用

**项目规范**：
- `CodexFeatured/Common/BackendConstitution.yaml` - 技术栈约束与禁止项
- `CodexFeatured/Common/BestPractise.yaml` - 架构模式推荐
- `CodexFeatured/Common/CodebaseStructure.yaml` - 项目结构文档
- `Kobe/index.yaml` - 项目能力索引

**工作流版本**：2.0 | **最后更新**：2025-10-11

---

*基于 SpecKit 工程实践 v2.1.1 - 专注架构设计与模块规划*

